#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2025 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by GitHub CoPilot (Claude Sonnet 4) and reviewed by a human committer

import sys
import os
import pytest
import hashlib
from sqlmodel import SQLModel, create_engine, Session

from tractusx_sdk.dataspace.models.governance.policy_db_models import (
    Policy, PolicyUsage, PolicyUsageRole, Rule, Action, ActionType,
    AtomicConstraint, Constraint, ConstraintAtomicLink, Permission, 
    Prohibition, Duty, LeftOperand, RightOperand, FilterExpression,
    OperatorType, LogicType
)


class TestPolicyDBModels:
    """Test suite for policy database models"""
    
    @pytest.fixture
    def engine(self):
        """Create an in-memory SQLite engine for testing"""
        engine = create_engine("sqlite:///:memory:")
        SQLModel.metadata.create_all(engine)
        return engine
    
    @pytest.fixture
    def session(self, engine):
        """Create a database session for testing"""
        with Session(engine) as session:
            yield session
    
    def test_policy_usage_role_enum(self):
        """Test PolicyUsageRole enum values"""
        assert PolicyUsageRole.PROVIDER == "provider"
        assert PolicyUsageRole.CONSUMER == "consumer"
    
    def test_action_type_enum(self):
        """Test ActionType enum values"""
        assert ActionType.USE == "odrl:use"
        assert ActionType.ACCESS == "odrl:access"
    
    def test_operator_type_enum(self):
        """Test OperatorType enum values"""
        assert OperatorType.eq == "odrl:eq"
        assert OperatorType.gt == "odrl:gt"
        assert OperatorType.gteq == "odrl:gteq"
        assert OperatorType.lteq == "odrl:lteq"
        assert OperatorType.neq == "odrl:neq"
    
    def test_logic_type_enum(self):
        """Test LogicType enum values"""
        assert LogicType.ATOMIC == "atomic"
        assert LogicType.AND == "odrl:and"
        assert LogicType.OR == "odrl:or"
    
    def test_left_operand_creation_and_hash(self):
        """Test LeftOperand model creation and hash generation"""
        value = "cx-policy:FrameworkAgreement"
        operand = LeftOperand(value=value)
        
        # Test basic properties
        assert operand.value == value
        assert isinstance(operand.hash, str)
        assert len(operand.hash) == 64  # SHA256 hash length
        
        # Test hash consistency
        expected_hash = hashlib.sha256(value.encode()).hexdigest()
        assert operand.hash == expected_hash
        
        # Test static method
        static_hash = LeftOperand.generate_hash(value)
        assert static_hash == expected_hash
    
    def test_right_operand_creation_and_hash(self):
        """Test RightOperand model creation and hash generation"""
        value = "DataExchangeGovernance:1.0"
        operand = RightOperand(value=value)
        
        # Test basic properties
        assert operand.value == value
        assert isinstance(operand.hash, str)
        assert len(operand.hash) == 64
        
        # Test hash consistency
        expected_hash = hashlib.sha256(value.encode()).hexdigest()
        assert operand.hash == expected_hash
    
    def test_atomic_constraint_creation_and_hash(self):
        """Test AtomicConstraint model creation and hash generation"""
        left_id = 1
        operator = OperatorType.eq
        right_id = 2
        
        constraint = AtomicConstraint(
            left_operand_id=left_id,
            operator=operator,
            right_operand_id=right_id
        )
        
        # Test basic properties
        assert constraint.left_operand_id == left_id
        assert constraint.operator == operator
        assert constraint.right_operand_id == right_id
        assert isinstance(constraint.hash, str)
        assert len(constraint.hash) == 64
        
        # Test hash generation
        expected_hash = AtomicConstraint.generate_hash(str(left_id), str(operator), str(right_id))
        assert constraint.hash == expected_hash
    
    def test_action_creation_and_hash(self):
        """Test Action model creation and hash generation"""
        action_type = ActionType.USE
        action = Action(type=action_type)
        
        assert action.type == action_type
        assert isinstance(action.hash, str)
        assert len(action.hash) == 64
        
        # Test hash generation
        expected_hash = Action.generate_hash(action_type)
        assert action.hash == expected_hash
    
    def test_constraint_hash_generation(self):
        """Test Constraint model hash generation with atomic hashes"""
        atomic_hashes = ["hash1", "hash2", "hash3"]
        expected_hash = Constraint.generate_hash(atomic_hashes)
        
        # Test that the hash is deterministic (sorted)
        expected_raw = ":".join(sorted(atomic_hashes))
        manual_hash = hashlib.sha256(expected_raw.encode()).hexdigest()
        assert expected_hash == manual_hash
        
        # Test that order doesn't matter
        shuffled_hashes = ["hash3", "hash1", "hash2"]
        shuffled_expected = Constraint.generate_hash(shuffled_hashes)
        assert expected_hash == shuffled_expected
    
    def test_rule_hash_generation(self):
        """Test Rule model hash generation"""
        action_hash = "action_hash_123"
        constraint_hash = "constraint_hash_456"
        
        expected_hash = Rule.generate_hash(action_hash, constraint_hash)
        
        # Verify the hash format
        expected_raw = f"{action_hash}:{constraint_hash}"
        manual_hash = hashlib.sha256(expected_raw.encode()).hexdigest()
        assert expected_hash == manual_hash
    
    def test_permission_hash_generation(self):
        """Test Permission model hash generation"""
        rule_hash = "rule_hash_123"
        duty_hash = "duty_hash_456"
        
        expected_hash = Permission.generate_hash(rule_hash, duty_hash)
        
        expected_raw = f"{rule_hash}:{duty_hash}"
        manual_hash = hashlib.sha256(expected_raw.encode()).hexdigest()
        assert expected_hash == manual_hash
    
    def test_prohibition_hash_generation(self):
        """Test Prohibition model hash generation"""
        rule_hash = "rule_hash_123"
        remedy_hash = "remedy_hash_456"
        
        expected_hash = Prohibition.generate_hash(rule_hash, remedy_hash)
        
        expected_raw = f"{rule_hash}:{remedy_hash}"
        manual_hash = hashlib.sha256(expected_raw.encode()).hexdigest()
        assert expected_hash == manual_hash
    
    def test_duty_hash_generation(self):
        """Test Duty model hash generation"""
        rule_hash = "rule_hash_123"
        consequence_hash = "consequence_hash_456"
        
        expected_hash = Duty.generate_hash(rule_hash, consequence_hash)
        
        expected_raw = f"{rule_hash}:{consequence_hash}"
        manual_hash = hashlib.sha256(expected_raw.encode()).hexdigest()
        assert expected_hash == manual_hash
    
    def test_policy_hash_generation(self):
        """Test Policy model hash generation"""
        permission_hash = "permission_hash_123"
        prohibition_hash = "prohibition_hash_456"
        obligation_hash = "obligation_hash_789"
        
        expected_hash = Policy.generate_hash(permission_hash, prohibition_hash, obligation_hash)
        
        # Test that it sorts the hashes
        combined = ":".join(sorted([permission_hash, prohibition_hash, obligation_hash]))
        manual_hash = hashlib.sha256(combined.encode()).hexdigest()
        assert expected_hash == manual_hash
    
    def test_filter_expression_creation_and_hash(self):
        """Test FilterExpression model creation and hash generation"""
        left = "https://w3id.org/edc/v0.0.1/ns/id"
        operator = OperatorType.eq
        right = "ichub:asset:1qgpKiRoLcs_PC6oOYsHHQ"
        
        filter_expr = FilterExpression(
            policy_usage_id=1,
            operand_left=left,
            operator=operator,
            operand_right=right
        )
        
        assert filter_expr.operand_left == left
        assert filter_expr.operator == operator
        assert filter_expr.operand_right == right
        assert isinstance(filter_expr.hash, str)
        assert len(filter_expr.hash) == 64
        
        # Test hash generation
        expected_hash = FilterExpression.generate_hash(left, str(operator), right)
        assert filter_expr.hash == expected_hash
    
    def test_database_operations(self, session):
        """Test basic database operations with the models"""
        # Create a LeftOperand
        left_operand = LeftOperand(value="test:left")
        session.add(left_operand)
        session.commit()
        
        # Create a RightOperand
        right_operand = RightOperand(value="test_value")
        session.add(right_operand)
        session.commit()
        
        # Create an AtomicConstraint
        atomic_constraint = AtomicConstraint(
            left_operand_id=left_operand.id,
            operator=OperatorType.eq,
            right_operand_id=right_operand.id
        )
        session.add(atomic_constraint)
        session.commit()
        
        # Verify the constraint was saved
        assert atomic_constraint.id is not None
        assert atomic_constraint.left_operand_id == left_operand.id
        assert atomic_constraint.right_operand_id == right_operand.id
        
        # Test relationships (note: relationships need to be loaded in the session)
        session.refresh(atomic_constraint)
        assert atomic_constraint.left_operand.value == "test:left"
        assert atomic_constraint.right_operand.value == "test_value"
    
    def test_policy_creation_with_empty_hashes(self):
        """Test Policy creation with empty component hashes"""
        policy = Policy(
            permission=None,
            prohibition=None,
            obligation=None
        )
        
        # Should handle empty hashes gracefully
        assert isinstance(policy.hash, str)
        assert len(policy.hash) == 64
        
        # Test with empty strings
        expected_hash = Policy.generate_hash("", "", "")
        assert policy.hash == expected_hash
    
    def test_constraint_with_empty_atomic_list(self):
        """Test Constraint creation with empty atomic constraints list"""
        constraint = Constraint(
            logic_type=LogicType.AND,
            constraints=[]
        )
        
        # Should handle empty constraints list
        expected_hash = Constraint.generate_hash([])
        assert constraint.hash == expected_hash
        
        # Empty list should produce consistent hash
        empty_hash = hashlib.sha256("".encode()).hexdigest()
        assert expected_hash == empty_hash
    
    def test_hash_consistency_across_instances(self):
        """Test that identical models produce identical hashes"""
        # Create two identical LeftOperands
        operand1 = LeftOperand(value="test_value")
        operand2 = LeftOperand(value="test_value")
        
        assert operand1.hash == operand2.hash
        
        # Create two identical Actions
        action1 = Action(type=ActionType.USE)
        action2 = Action(type=ActionType.USE)
        
        assert action1.hash == action2.hash
        
        # Test with different values
        operand3 = LeftOperand(value="different_value")
        assert operand1.hash != operand3.hash
    
    def test_unique_hash_constraint(self, session):
        """Test that unique hash constraints are enforced"""
        # Create first operand
        operand1 = LeftOperand(value="unique_test")
        session.add(operand1)
        session.commit()
        
        # Try to create second operand with same value (should have same hash)
        operand2 = LeftOperand(value="unique_test")
        session.add(operand2)
        
        # This should raise an integrity error due to unique constraint on hash
        with pytest.raises(Exception):  # SQLite will raise an IntegrityError
            session.commit()
    
    def test_policy_usage_creation(self, session):
        """Test PolicyUsage model creation"""
        # First create a Policy
        policy = Policy()
        session.add(policy)
        session.commit()
        
        # Create PolicyUsage
        policy_usage = PolicyUsage(
            policy_id=policy.id,
            role=PolicyUsageRole.CONSUMER,
            counter_party_id="test_party"
        )
        session.add(policy_usage)
        session.commit()
        
        assert policy_usage.policy_id == policy.id
        assert policy_usage.role == PolicyUsageRole.CONSUMER
        assert policy_usage.counter_party_id == "test_party"
    
    def test_complete_policy_structure(self, session):
        """Test creating a complete policy structure"""
        # Create operands
        left_operand = LeftOperand(value="cx-policy:FrameworkAgreement")
        right_operand = RightOperand(value="DataExchangeGovernance:1.0")
        session.add_all([left_operand, right_operand])
        session.commit()
        
        # Create atomic constraint
        atomic_constraint = AtomicConstraint(
            left_operand_id=left_operand.id,
            operator=OperatorType.eq,
            right_operand_id=right_operand.id
        )
        session.add(atomic_constraint)
        session.commit()
        
        # Create constraint
        constraint = Constraint(logic_type=LogicType.ATOMIC)
        session.add(constraint)
        session.commit()
        
        # Create constraint-atomic link
        link = ConstraintAtomicLink(
            constraint_id=constraint.id,
            atomicconstraint_id=atomic_constraint.id
        )
        session.add(link)
        session.commit()
        
        # Create action
        action = Action(type=ActionType.USE)
        session.add(action)
        session.commit()
        
        # Create rule
        rule = Rule(
            action_id=action.id,
            constraint_id=constraint.id
        )
        session.add(rule)
        session.commit()
        
        # Create policy
        policy = Policy()
        session.add(policy)
        session.commit()
        
        # Create permission
        duty = Duty(rule_id=rule.id, consequence_id=None, policy_id=policy.id)
        session.add(duty)
        session.commit()
        
        permission = Permission(
            rule_id=rule.id,
            duty_id=duty.id,
            policy_id=policy.id
        )
        session.add(permission)
        session.commit()
        
        # Verify the complete structure
        assert permission.policy_id == policy.id
        assert permission.rule_id == rule.id
        assert rule.action_id == action.id
        assert rule.constraint_id == constraint.id
        
        # Test hash generation worked
        assert len(permission.hash) == 64
        assert len(rule.hash) == 64
        assert len(policy.hash) == 64


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
