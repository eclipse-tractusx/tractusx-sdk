#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2026 LKS NEXT
# Copyright (c) 2026 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by Co-Pilot and reviewed by a human developer.

import pytest
from unittest.mock import MagicMock, patch

from tractusx_sdk.extensions.notification_api import (
    NotificationConsumerService,
    Notification,
    NotificationError,
    NotificationValidationError,
    DIGITAL_TWIN_EVENT_API_TYPE,
)


# Test fixtures
@pytest.fixture
def sample_notification() -> Notification:
    """Create a sample notification for testing following Industry Core schema."""
    return (
        Notification.builder()
        .sender_bpn("BPNL000000000001")
        .receiver_bpn("BPNL000000000002")
        .context("IndustryCore-DigitalTwinEventAPI-ConnectToParent:3.0.0")
        .information("Test notification content")
        .build()
    )


@pytest.fixture
def mock_connector_consumer():
    """Create a mock connector consumer service."""
    mock_instance = MagicMock()
    return mock_instance


class TestNotificationConsumerServiceConstruction:
    """Tests for NotificationConsumerService construction."""
    
    def test_direct_construction(self, mock_connector_consumer):
        """Test direct construction with all parameters."""
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
            verbose=True,
        )
        
        assert service is not None
        assert service.verbose is True
        assert service.connector_consumer is mock_connector_consumer
    
    def test_builder_construction(self, mock_connector_consumer):
        """Test builder pattern construction."""
        service = (
            NotificationConsumerService.builder()
            .connector_consumer(mock_connector_consumer)
            .verbose(False)
            .build()
        )
        
        assert service is not None
        assert service.verbose is False
        assert service.connector_consumer is mock_connector_consumer
    
    def test_construction_without_connector_consumer(self):
        """Test construction without connector consumer."""
        service = NotificationConsumerService()
        
        assert service is not None
        assert service.connector_consumer is None
    
    def test_builder_with_data(self, mock_connector_consumer):
        """Test builder with data() method."""
        service = (
            NotificationConsumerService.builder()
            .data({
                "connector_consumer": mock_connector_consumer,
            })
            .build()
        )
        
        assert service is not None
        assert service.connector_consumer is mock_connector_consumer
    
    def test_connector_consumer_property(self, mock_connector_consumer):
        """Test connector_consumer property returns the underlying service."""
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        assert service.connector_consumer is mock_connector_consumer


class TestDiscoverNotificationAssets:
    """Tests for discovering notification assets."""
    
    def test_discover_notification_assets_single_result(self, mock_connector_consumer):
        """Test discovering a single notification asset."""
        mock_connector_consumer.get_catalog_by_dct_type.return_value = {
            "dcat:dataset": {
                "@id": "asset-123",
                "dct:type": {"@id": DIGITAL_TWIN_EVENT_API_TYPE},
            }
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        assets = service.discover_notification_assets(
            provider_bpn="BPNL000000000002",
            provider_dsp_url="https://provider.com/dsp",
        )
        
        assert len(assets) == 1
        assert assets[0]["@id"] == "asset-123"
    
    def test_discover_notification_assets_multiple_results(self, mock_connector_consumer):
        """Test discovering multiple notification assets."""
        mock_connector_consumer.get_catalog_by_dct_type.return_value = {
            "dcat:dataset": [
                {"@id": "asset-123"},
                {"@id": "asset-456"},
            ]
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        assets = service.discover_notification_assets(
            provider_bpn="BPNL000000000002",
            provider_dsp_url="https://provider.com/dsp",
        )
        
        assert len(assets) == 2
    
    def test_discover_notification_assets_empty_result(self, mock_connector_consumer):
        """Test discovering when no assets found."""
        mock_connector_consumer.get_catalog_by_dct_type.return_value = {
            "dcat:dataset": []
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        assets = service.discover_notification_assets(
            provider_bpn="BPNL000000000002",
            provider_dsp_url="https://provider.com/dsp",
        )
        
        assert len(assets) == 0
    
    def test_discover_notification_assets_error(self, mock_connector_consumer):
        """Test error handling when discovery fails."""
        mock_connector_consumer.get_catalog_by_dct_type.side_effect = Exception("Connection failed")
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with pytest.raises(NotificationError) as exc_info:
            service.discover_notification_assets(
                provider_bpn="BPNL000000000002",
                provider_dsp_url="https://provider.com/dsp",
            )
        
        assert "Connection failed" in str(exc_info.value)


class TestNegotiateNotificationAccess:
    """Tests for negotiating notification access."""
    
    def test_negotiate_notification_access_success(self, mock_connector_consumer):
        """Test successful negotiation."""
        mock_connector_consumer.get_filter_expression.return_value = {
            "operandLeft": "dct:type",
            "operator": "=",
            "operandRight": DIGITAL_TWIN_EVENT_API_TYPE,
        }
        mock_connector_consumer.negotiate_and_transfer.return_value = {
            "transferProcessId": "transfer-123",
            "contractAgreementId": "agreement-456",
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        edr_entry = service.negotiate_notification_access(
            provider_bpn="BPNL000000000002",
            provider_dsp_url="https://provider.com/dsp",
        )
        
        assert edr_entry["transferProcessId"] == "transfer-123"
        assert edr_entry["contractAgreementId"] == "agreement-456"
    
    def test_negotiate_notification_access_with_policies(self, mock_connector_consumer):
        """Test negotiation with specific policies."""
        mock_connector_consumer.get_filter_expression.return_value = {}
        mock_connector_consumer.negotiate_and_transfer.return_value = {
            "transferProcessId": "transfer-123",
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        policies = [{"permission": {"@type": "Set"}}]
        
        service.negotiate_notification_access(
            provider_bpn="BPNL000000000002",
            provider_dsp_url="https://provider.com/dsp",
            policies=policies,
        )
        
        mock_connector_consumer.negotiate_and_transfer.assert_called_once()
        call_kwargs = mock_connector_consumer.negotiate_and_transfer.call_args[1]
        assert call_kwargs["policies"] == policies
    
    def test_negotiate_notification_access_error(self, mock_connector_consumer):
        """Test error handling during negotiation."""
        mock_connector_consumer.get_filter_expression.return_value = {}
        mock_connector_consumer.negotiate_and_transfer.side_effect = Exception("Negotiation failed")
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with pytest.raises(NotificationError) as exc_info:
            service.negotiate_notification_access(
                provider_bpn="BPNL000000000002",
                provider_dsp_url="https://provider.com/dsp",
            )
        
        assert "Negotiation failed" in str(exc_info.value)


class TestGetNotificationEndpoint:
    """Tests for getting notification endpoint."""
    
    def test_get_notification_endpoint_success(self, mock_connector_consumer):
        """Test successfully getting endpoint and token."""
        mock_connector_consumer.do_dsp_by_dct_type.return_value = (
            "https://dataplane.com/notifications",
            "Bearer token123",
        )
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        endpoint, token = service.get_notification_endpoint(
            provider_bpn="BPNL000000000002",
            provider_dsp_url="https://provider.com/dsp",
        )
        
        assert endpoint == "https://dataplane.com/notifications"
        assert token == "Bearer token123"
    
    def test_get_notification_endpoint_error(self, mock_connector_consumer):
        """Test error handling when getting endpoint fails."""
        mock_connector_consumer.do_dsp_by_dct_type.side_effect = Exception("DSP exchange failed")
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with pytest.raises(NotificationError) as exc_info:
            service.get_notification_endpoint(
                provider_bpn="BPNL000000000002",
                provider_dsp_url="https://provider.com/dsp",
            )
        
        assert "DSP exchange failed" in str(exc_info.value)


class TestSendNotification:
    """Tests for sending notifications."""
    
    def test_send_notification_success(self, mock_connector_consumer, sample_notification):
        """Test successfully sending a notification."""
        mock_connector_consumer.do_dsp_by_dct_type.return_value = (
            "https://dataplane.com/notifications",
            "Bearer token123",
        )
        mock_connector_consumer.get_data_plane_headers.return_value = {
            "Authorization": "Bearer token123",
            "Content-Type": "application/json",
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = '{"status": "received"}'
            mock_response.json.return_value = {"status": "received"}
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url = lambda a, b: f"{a}/{b}" if b else a
            
            result = service.send_notification(
                provider_bpn="BPNL000000000002",
                provider_dsp_url="https://provider.com/dsp",
                notification=sample_notification,
            )
        
        assert result["status"] == "received"
    
    def test_send_notification_with_endpoint_path(self, mock_connector_consumer, sample_notification):
        """Test sending notification with custom endpoint path."""
        mock_connector_consumer.do_dsp_by_dct_type.return_value = (
            "https://dataplane.com",
            "Bearer token123",
        )
        mock_connector_consumer.get_data_plane_headers.return_value = {}
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 202
            mock_response.text = ""
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url.return_value = "https://dataplane.com/receive"
            
            service.send_notification(
                provider_bpn="BPNL000000000002",
                provider_dsp_url="https://provider.com/dsp",
                notification=sample_notification,
                endpoint_path="receive",
            )
            
            mock_http.concat_into_url.assert_called_with("https://dataplane.com", "receive")
    
    def test_send_notification_error_response(self, mock_connector_consumer, sample_notification):
        """Test error handling for failed HTTP response."""
        mock_connector_consumer.do_dsp_by_dct_type.return_value = (
            "https://dataplane.com/notifications",
            "Bearer token123",
        )
        mock_connector_consumer.get_data_plane_headers.return_value = {}
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 500
            mock_response.text = "Internal Server Error"
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url = lambda a, b: f"{a}/{b}" if b else a
            
            with pytest.raises(NotificationError) as exc_info:
                service.send_notification(
                    provider_bpn="BPNL000000000002",
                    provider_dsp_url="https://provider.com/dsp",
                    notification=sample_notification,
                )
            
            assert "500" in str(exc_info.value)
    
    def test_send_notification_validation_error(self, mock_connector_consumer):
        """Test validation error for invalid notification."""
        from pydantic import ValidationError
        
        NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        # Creating notification without required fields raises Pydantic ValidationError
        with pytest.raises(ValidationError) as exc_info:
            Notification.builder() \
                .receiver_bpn("BPNL000000000002") \
                .information("Test") \
                .build()
        
        # senderBpn is required in Industry Core schema
        assert "sender_bpn" in str(exc_info.value).lower() or "context" in str(exc_info.value).lower()


class TestSendNotificationToEndpoint:
    """Tests for sending to a specific endpoint."""
    
    def test_send_to_endpoint_success(self, mock_connector_consumer, sample_notification):
        """Test sending notification to a specific endpoint with token."""
        mock_connector_consumer.get_data_plane_headers.return_value = {
            "Authorization": "Bearer token123",
        }
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = '{"status": "ok"}'
            mock_response.json.return_value = {"status": "ok"}
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url = lambda a, b: f"{a}/{b}" if b else a
            
            result = service.send_notification_to_endpoint(
                endpoint_url="https://cached-endpoint.com",
                access_token="token123",
                notification=sample_notification,
            )
        
        assert result["status"] == "ok"
    
    def test_send_to_endpoint_with_path(self, mock_connector_consumer, sample_notification):
        """Test sending to endpoint with custom path."""
        mock_connector_consumer.get_data_plane_headers.return_value = {}
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = "{}"
            mock_response.json.return_value = {}
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url.return_value = "https://endpoint.com/custom/path"
            
            service.send_notification_to_endpoint(
                endpoint_url="https://endpoint.com",
                access_token="token123",
                notification=sample_notification,
                endpoint_path="custom/path",
            )
            
            mock_http.concat_into_url.assert_called_with("https://endpoint.com", "custom/path")


class TestSendToMultipleProviders:
    """Tests for sending to multiple providers."""
    
    def test_send_to_multiple_providers_all_success(self, mock_connector_consumer, sample_notification):
        """Test sending to multiple providers successfully."""
        mock_connector_consumer.do_dsp_by_dct_type.return_value = (
            "https://dataplane.com",
            "token123",
        )
        mock_connector_consumer.get_data_plane_headers.return_value = {}
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        providers = [
            {"bpn": "BPNL000000000001", "dsp_url": "https://provider1.com/dsp"},
            {"bpn": "BPNL000000000002", "dsp_url": "https://provider2.com/dsp"},
        ]
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = '{"status": "ok"}'
            mock_response.json.return_value = {"status": "ok"}
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url = lambda a, b: f"{a}/{b}" if b else a
            
            results = service.send_to_multiple_providers(
                providers=providers,
                notification=sample_notification,
            )
        
        assert results["BPNL000000000001"]["success"] is True
        assert results["BPNL000000000002"]["success"] is True
    
    def test_send_to_multiple_providers_partial_failure(self, mock_connector_consumer, sample_notification):
        """Test partial failure when sending to multiple providers."""
        def dsp_side_effect(*args, **kwargs):
            if kwargs.get("counter_party_id") == "BPNL000000000001":
                return ("https://dataplane.com", "token123")
            raise NotificationError("Provider unavailable")
        
        mock_connector_consumer.do_dsp_by_dct_type.side_effect = dsp_side_effect
        mock_connector_consumer.get_data_plane_headers.return_value = {}
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        providers = [
            {"bpn": "BPNL000000000001", "dsp_url": "https://provider1.com/dsp"},
            {"bpn": "BPNL000000000002", "dsp_url": "https://provider2.com/dsp"},
        ]
        
        with patch("tractusx_sdk.extensions.notification_api.services.notification_consumer_service.HttpTools") as mock_http:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = '{"status": "ok"}'
            mock_response.json.return_value = {"status": "ok"}
            mock_http.do_post.return_value = mock_response
            mock_http.concat_into_url = lambda a, b: f"{a}/{b}" if b else a
            
            results = service.send_to_multiple_providers(
                providers=providers,
                notification=sample_notification,
            )
        
        assert results["BPNL000000000001"]["success"] is True
        assert results["BPNL000000000002"]["success"] is False
        assert "Provider unavailable" in results["BPNL000000000002"]["error"]
    
    def test_send_to_multiple_providers_stop_on_error(self, mock_connector_consumer, sample_notification):
        """Test stopping on first error when requested."""
        mock_connector_consumer.do_dsp_by_dct_type.side_effect = Exception("First failure")
        
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        providers = [
            {"bpn": "BPNL000000000001", "dsp_url": "https://provider1.com/dsp"},
            {"bpn": "BPNL000000000002", "dsp_url": "https://provider2.com/dsp"},
        ]
        
        results = service.send_to_multiple_providers(
            providers=providers,
            notification=sample_notification,
            stop_on_error=True,
        )
        
        assert "BPNL000000000001" in results
        assert results["BPNL000000000001"]["success"] is False
        # Second provider should not be attempted
        assert "BPNL000000000002" not in results
    
    def test_send_to_multiple_providers_missing_config(self, mock_connector_consumer, sample_notification):
        """Test handling providers with missing configuration."""
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        providers = [
            {"bpn": "BPNL000000000001"},  # Missing dsp_url
            {"dsp_url": "https://provider2.com/dsp"},  # Missing bpn
        ]
        
        results = service.send_to_multiple_providers(
            providers=providers,
            notification=sample_notification,
        )
        
        assert results["BPNL000000000001"]["success"] is False
        assert "Missing" in results["BPNL000000000001"]["error"]
        assert results["unknown"]["success"] is False


class TestNotificationValidation:
    """Tests for notification validation."""
    
    def test_validation_same_sender_recipient(self, mock_connector_consumer):
        """Test validation error when sender and receiver are the same."""
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        # Create notification where sender and receiver are the same
        notification = (
            Notification.builder()
            .sender_bpn("BPNL000000000001")
            .receiver_bpn("BPNL000000000001")  # Same as sender
            .context("IndustryCore-DigitalTwinEventAPI-ConnectToParent:3.0.0")
            .information("Test")
            .build()
        )
        
        with pytest.raises(NotificationValidationError) as exc_info:
            service.send_notification(
                provider_bpn="BPNL000000000001",
                provider_dsp_url="https://provider.com/dsp",
                notification=notification,
            )
        
        assert "cannot be the same" in str(exc_info.value)
    
    def test_validation_missing_context(self, mock_connector_consumer):
        """Test validation error when context is missing."""
        from pydantic import ValidationError
        
        NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        # Creating notification without context raises Pydantic ValidationError
        with pytest.raises(ValidationError) as exc_info:
            Notification.builder() \
                .sender_bpn("BPNL000000000001") \
                .receiver_bpn("BPNL000000000002") \
                .information("Test") \
                .build()
        
        assert "context" in str(exc_info.value)


class TestDigitalTwinEventApiType:
    """Tests for DigitalTwinEventAPI type constant."""
    
    def test_type_constant_matches(self, mock_connector_consumer):
        """Test that service uses correct type constant."""
        service = NotificationConsumerService(
            connector_consumer=mock_connector_consumer,
        )
        
        assert service.DIGITAL_TWIN_EVENT_API_TYPE == DIGITAL_TWIN_EVENT_API_TYPE
        assert service.DIGITAL_TWIN_EVENT_API_TYPE == "https://w3id.org/catenax/taxonomy#DigitalTwinEventAPI"
