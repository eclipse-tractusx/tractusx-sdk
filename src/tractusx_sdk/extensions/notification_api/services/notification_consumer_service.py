#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2026 LKS NEXT
# Copyright (c) 2026 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by Co-Pilot and reviewed by a human developer.

"""
Notification Consumer Service for sending notifications through the dataspace.

Provides functionality to discover DigitalTwinEventAPI assets in provider connectors,
negotiate contracts, obtain EDR tokens, and send notifications through the dataspace.
"""

import logging
from typing import Any, Dict, List, Optional

from tractusx_sdk.dataspace.services.connector.base_connector_consumer import BaseConnectorConsumerService
from tractusx_sdk.dataspace.tools import HttpTools

from ..constants import DIGITAL_TWIN_EVENT_API_TYPE, DCT_TYPE_KEY
from ..models import Notification
from ..exceptions import (
    NotificationError,
    NotificationValidationError,
)


class NotificationConsumerService:
    """
    Service for sending notifications through the Catena-X dataspace.
    
    This service handles the complete EDC negotiation flow:
    1. Request catalog from provider connector
    2. Find DigitalTwinEventAPI assets
    3. Negotiate contract and transfer
    4. Obtain EDR token
    5. Send notification to the provider's notification endpoint
    
    This service does NOT expose REST endpoints - it provides reusable
    business logic that consuming applications can integrate.
    
    Attributes:
        _connector_consumer: BaseConnectorConsumerService for EDC operations
        verbose: Enable verbose logging
        logger: Logger instance for this service
    """
    
    # DCT type for notification assets
    DIGITAL_TWIN_EVENT_API_TYPE = DIGITAL_TWIN_EVENT_API_TYPE
    
    _connector_consumer: Optional[BaseConnectorConsumerService]
    verbose: bool
    logger: logging.Logger
    
    def __init__(
        self,
        connector_consumer: Optional[BaseConnectorConsumerService] = None,
        verbose: bool = True,
        logger: Optional[logging.Logger] = None,
    ):
        """
        Initialize the NotificationConsumerService.
        
        Args:
            connector_consumer: BaseConnectorConsumerService for EDC operations
            verbose: Enable verbose logging (default: True)
            logger: Optional custom logger instance
        """
        self.verbose = verbose
        self.logger = logger or logging.getLogger(__name__)
        self._connector_consumer = connector_consumer
    
    @property
    def connector_consumer(self) -> Optional[BaseConnectorConsumerService]:
        """Get the underlying connector consumer service."""
        return self._connector_consumer
    
    def _ensure_connector_consumer(self) -> BaseConnectorConsumerService:
        """
        Ensure connector consumer is configured.
        
        Returns:
            The configured connector consumer service
            
        Raises:
            NotificationError: If connector consumer is not configured
        """
        if self._connector_consumer is None:
            raise NotificationError(
                "Connector consumer is required for this operation. "
                "Initialize the service with a connector_consumer parameter."
            )
        return self._connector_consumer
    
    def discover_notification_assets(
        self,
        provider_bpn: str,
        provider_dsp_url: str,
        timeout: int = 60,
    ) -> List[Dict[str, Any]]:
        """
        Discover DigitalTwinEventAPI assets in a provider's catalog.
        
        Queries the provider's connector catalog for assets with
        dct:type = cx-taxo:DigitalTwinEventAPI.
        
        Args:
            provider_bpn: Business Partner Number of the provider
            provider_dsp_url: DSP endpoint URL of the provider connector
            timeout: Request timeout in seconds (default: 60)
            
        Returns:
            List of catalog datasets (assets) matching the notification type
            
        Raises:
            NotificationError: If catalog retrieval fails
        """
        connector = self._ensure_connector_consumer()
        
        if self.verbose:
            self.logger.info(
                f"Discovering notification assets from provider {provider_bpn} "
                f"at {provider_dsp_url}"
            )
        
        try:
            catalog = connector.get_catalog_by_dct_type(
                counter_party_id=provider_bpn,
                counter_party_address=provider_dsp_url,
                dct_type=self.DIGITAL_TWIN_EVENT_API_TYPE,
                dct_type_key=DCT_TYPE_KEY,
                timeout=timeout,
            )
            
            # Extract datasets from catalog
            datasets = catalog.get("dcat:dataset", [])
            if isinstance(datasets, dict):
                datasets = [datasets]
            
            if self.verbose:
                self.logger.info(
                    f"Found {len(datasets)} DigitalTwinEventAPI asset(s) in catalog"
                )
            
            return datasets
            
        except Exception as e:
            self.logger.error(f"Failed to discover notification assets: {e}")
            raise NotificationError(f"Failed to discover notification assets: {e}")
    
    def negotiate_notification_access(
        self,
        provider_bpn: str,
        provider_dsp_url: str,
        policies: Optional[List[Dict]] = None,
        max_retries: int = 6,
        retry_timeout: int = 10,
    ) -> Dict[str, Any]:
        """
        Negotiate access to a DigitalTwinEventAPI asset.
        
        Performs the complete negotiation flow:
        1. Query catalog for DigitalTwinEventAPI assets
        2. Select asset and policy
        3. Start EDR negotiation
        4. Wait for EDR entry
        
        Args:
            provider_bpn: Business Partner Number of the provider
            provider_dsp_url: DSP endpoint URL of the provider connector
            policies: Optional list of allowed policies for negotiation
            max_retries: Maximum retries for EDR entry (default: 6)
            retry_timeout: Timeout between retries in seconds (default: 10)
            
        Returns:
            EDR entry dictionary containing transfer process ID and agreement details
            
        Raises:
            NotificationError: If negotiation fails
        """
        connector = self._ensure_connector_consumer()
        
        if self.verbose:
            self.logger.info(
                f"Negotiating notification access with provider {provider_bpn}"
            )
        
        try:
            filter_expression = [
                connector.get_filter_expression(
                    key=DCT_TYPE_KEY,
                    value=self.DIGITAL_TWIN_EVENT_API_TYPE,
                    operator="=",
                )
            ]
            
            edr_entry = connector.negotiate_and_transfer(
                counter_party_id=provider_bpn,
                counter_party_address=provider_dsp_url,
                filter_expression=filter_expression,
                policies=policies,
                max_retries=max_retries,
                timeout=retry_timeout,
            )
            
            if self.verbose:
                transfer_id = edr_entry.get("transferProcessId", "unknown")
                self.logger.info(
                    f"Successfully negotiated notification access. "
                    f"Transfer ID: {transfer_id}"
                )
            
            return edr_entry
            
        except Exception as e:
            self.logger.error(f"Failed to negotiate notification access: {e}")
            raise NotificationError(f"Failed to negotiate notification access: {e}")
    
    def get_notification_endpoint(
        self,
        provider_bpn: str,
        provider_dsp_url: str,
        policies: Optional[List[Dict]] = None,
    ) -> tuple[str, str]:
        """
        Get the notification endpoint and access token.
        
        Performs DSP exchange to obtain the dataplane endpoint and
        authorization token for sending notifications.
        
        Args:
            provider_bpn: Business Partner Number of the provider
            provider_dsp_url: DSP endpoint URL of the provider connector
            policies: Optional list of allowed policies for negotiation
            
        Returns:
            Tuple of (endpoint_url, authorization_token)
            
        Raises:
            NotificationError: If endpoint retrieval fails
        """
        connector = self._ensure_connector_consumer()
        
        if self.verbose:
            self.logger.info(
                f"Getting notification endpoint from provider {provider_bpn}"
            )
        
        try:
            endpoint, token = connector.do_dsp_by_dct_type(
                counter_party_id=provider_bpn,
                counter_party_address=provider_dsp_url,
                dct_type=self.DIGITAL_TWIN_EVENT_API_TYPE,
                dct_type_key=DCT_TYPE_KEY,
                policies=policies,
            )
            
            if self.verbose:
                self.logger.info(f"Obtained notification endpoint: {endpoint}")
            
            return endpoint, token
            
        except Exception as e:
            self.logger.error(f"Failed to get notification endpoint: {e}")
            raise NotificationError(f"Failed to get notification endpoint: {e}")
    
    def send_notification(
        self,
        provider_bpn: str,
        provider_dsp_url: str,
        notification: Notification,
        endpoint_path: str = "",
        policies: Optional[List[Dict]] = None,
        timeout: int = 30,
        verify_ssl: bool = True,
    ) -> Dict[str, Any]:
        """
        Send a notification through the dataspace.
        
        Performs the complete flow:
        1. Negotiate access to DigitalTwinEventAPI
        2. Obtain EDR token
        3. Send notification to the provider's endpoint
        
        Args:
            provider_bpn: Business Partner Number of the provider
            provider_dsp_url: DSP endpoint URL of the provider connector
            notification: The notification to send
            endpoint_path: Additional path to append to the dataplane endpoint
            policies: Optional list of allowed policies for negotiation
            timeout: Request timeout in seconds (default: 30)
            verify_ssl: Verify SSL certificates (default: True)
            
        Returns:
            Response data from the notification endpoint
            
        Raises:
            NotificationValidationError: If notification validation fails
            NotificationError: If sending fails
        """
        # Validate notification
        self._validate_notification(notification)
        
        connector = self._ensure_connector_consumer()
        
        if self.verbose:
            self.logger.info(
                f"Sending notification {notification.header.message_id} "
                f"to provider {provider_bpn} via DSP"
            )
        
        try:
            # Get endpoint and token through DSP
            endpoint, token = self.get_notification_endpoint(
                provider_bpn=provider_bpn,
                provider_dsp_url=provider_dsp_url,
                policies=policies,
            )
            
            # Build full URL with optional path
            if endpoint_path:
                full_url = HttpTools.concat_into_url(endpoint, endpoint_path)
            else:
                full_url = endpoint
            
            # Prepare headers with authorization
            headers = connector.get_data_plane_headers(
                access_token=token,
                content_type="application/json",
            )
            
            # Send notification
            response = HttpTools.do_post(
                url=full_url,
                json=notification.to_data(),
                headers=headers,
                timeout=timeout,
                verify=verify_ssl,
            )
            
            if response.status_code not in (200, 201, 202, 204):
                self.logger.error(
                    f"Failed to send notification: {response.status_code} - {response.text}"
                )
                raise NotificationError(
                    f"Failed to send notification {notification.header.message_id}. "
                    f"Status code: {response.status_code}"
                )
            
            if self.verbose:
                self.logger.info(
                    f"Successfully sent notification {notification.header.message_id}"
                )
            
            # Handle empty or non-JSON responses gracefully
            if not response.text or not response.text.strip():
                return {"status": "sent", "message_id": notification.header.message_id}
            
            try:
                return response.json()
            except Exception:
                # Response is not JSON, return status info
                return {"status": "sent", "message_id": notification.header.message_id}
            
        except NotificationError:
            raise
        except Exception as e:
            self.logger.error(f"Failed to send notification: {e}")
            raise NotificationError(f"Failed to send notification: {e}")
    
    def send_notification_to_endpoint(
        self,
        endpoint_url: str,
        access_token: str,
        notification: Notification,
        endpoint_path: str = "",
        timeout: int = 30,
        verify_ssl: bool = True,
    ) -> Dict[str, Any]:
        """
        Send a notification to a specific endpoint with a pre-obtained token.
        
        Use this method when you already have the endpoint and token
        (e.g., from a previous negotiation or cached EDR).
        
        Args:
            endpoint_url: The dataplane endpoint URL
            access_token: The authorization token
            notification: The notification to send
            endpoint_path: Additional path to append to the endpoint
            timeout: Request timeout in seconds (default: 30)
            verify_ssl: Verify SSL certificates (default: True)
            
        Returns:
            Response data from the notification endpoint
            
        Raises:
            NotificationValidationError: If notification validation fails
            NotificationError: If sending fails
        """
        # Validate notification
        self._validate_notification(notification)
        
        connector = self._ensure_connector_consumer()
        
        if self.verbose:
            self.logger.info(
                f"Sending notification {notification.header.message_id} "
                f"to endpoint {endpoint_url}"
            )
        
        try:
            # Build full URL with optional path
            if endpoint_path:
                full_url = HttpTools.concat_into_url(endpoint_url, endpoint_path)
            else:
                full_url = endpoint_url
            
            # Prepare headers with authorization
            headers = connector.get_data_plane_headers(
                access_token=access_token,
                content_type="application/json",
            )
            
            # Send notification
            response = HttpTools.do_post(
                url=full_url,
                json=notification.to_data(),
                headers=headers,
                timeout=timeout,
                verify=verify_ssl,
            )
            
            if response.status_code not in (200, 201, 202, 204):
                self.logger.error(
                    f"Failed to send notification: {response.status_code} - {response.text}"
                )
                raise NotificationError(
                    f"Failed to send notification {notification.header.message_id}. "
                    f"Status code: {response.status_code}"
                )
            
            if self.verbose:
                self.logger.info(
                    f"Successfully sent notification {notification.header.message_id}"
                )
            
            # Handle empty or non-JSON responses gracefully
            if not response.text or not response.text.strip():
                return {"status": "sent", "message_id": notification.header.message_id}
            
            try:
                return response.json()
            except Exception:
                # Response is not JSON, return status info
                return {"status": "sent", "message_id": notification.header.message_id}
            
        except NotificationError:
            raise
        except Exception as e:
            self.logger.error(f"Failed to send notification: {e}")
            raise NotificationError(f"Failed to send notification: {e}")
    
    def send_to_multiple_providers(
        self,
        providers: List[Dict[str, str]],
        notification: Notification,
        endpoint_path: str = "",
        policies: Optional[List[Dict]] = None,
        timeout: int = 30,
        verify_ssl: bool = True,
        stop_on_error: bool = False,
    ) -> Dict[str, Dict[str, Any]]:
        """
        Send a notification to multiple providers.
        
        Iterates through the list of providers, negotiates access,
        and sends the notification to each one.
        
        Args:
            providers: List of provider dictionaries with 'bpn' and 'dsp_url' keys
            notification: The notification to send
            endpoint_path: Additional path to append to each endpoint
            policies: Optional list of allowed policies for negotiation
            timeout: Request timeout in seconds (default: 30)
            verify_ssl: Verify SSL certificates (default: True)
            stop_on_error: Stop on first error (default: False, continues to next provider)
            
        Returns:
            Dictionary mapping provider BPN to result (success response or error)
            
        Example:
            ```python
            providers = [
                {"bpn": "BPNL000000000001", "dsp_url": "https://provider1.com/dsp"},
                {"bpn": "BPNL000000000002", "dsp_url": "https://provider2.com/dsp"},
            ]
            results = service.send_to_multiple_providers(providers, notification)
            ```
        """
        results: Dict[str, Dict[str, Any]] = {}
        
        for provider in providers:
            provider_bpn = provider.get("bpn")
            provider_dsp_url = provider.get("dsp_url")
            
            if not provider_bpn or not provider_dsp_url:
                results[provider_bpn or "unknown"] = {
                    "success": False,
                    "error": "Missing 'bpn' or 'dsp_url' in provider configuration",
                }
                continue
            
            try:
                response = self.send_notification(
                    provider_bpn=provider_bpn,
                    provider_dsp_url=provider_dsp_url,
                    notification=notification,
                    endpoint_path=endpoint_path,
                    policies=policies,
                    timeout=timeout,
                    verify_ssl=verify_ssl,
                )
                
                results[provider_bpn] = {
                    "success": True,
                    "response": response,
                }
                
            except Exception as e:
                results[provider_bpn] = {
                    "success": False,
                    "error": str(e),
                }
                
                if stop_on_error:
                    break
        
        return results
    
    def _validate_notification(self, notification: Notification) -> None:
        """
        Validate a notification before sending.
        
        Args:
            notification: The notification to validate
            
        Raises:
            NotificationValidationError: If validation fails
        """
        errors = []
        
        if not notification.header.sender_bpn:
            errors.append("sender_bpn is required")
        
        if not notification.header.receiver_bpn:
            errors.append("receiver_bpn is required")
        
        if not notification.header.context:
            errors.append("context is required")
        
        if notification.header.sender_bpn == notification.header.receiver_bpn:
            errors.append("sender_bpn and receiver_bpn cannot be the same")
        
        if errors:
            raise NotificationValidationError(
                f"Notification validation failed: {'; '.join(errors)}"
            )
    
    @classmethod
    def builder(cls) -> "NotificationConsumerService._Builder":
        """
        Create a builder for fluent service construction.
        
        Returns:
            Builder instance for creating NotificationConsumerService
        """
        return cls._Builder(cls)
    
    class _Builder:
        """Builder class for fluent NotificationConsumerService construction."""
        
        def __init__(self, cls):
            self.cls = cls
            self._data: Dict[str, Any] = {}
        
        def connector_consumer(
            self, connector_consumer: BaseConnectorConsumerService
        ) -> "NotificationConsumerService._Builder":
            """Set the connector consumer service for EDC operations."""
            self._data["connector_consumer"] = connector_consumer
            return self
        
        def verbose(self, verbose: bool) -> "NotificationConsumerService._Builder":
            """Enable or disable verbose logging."""
            self._data["verbose"] = verbose
            return self
        
        def logger(self, logger: logging.Logger) -> "NotificationConsumerService._Builder":
            """Set a custom logger."""
            self._data["logger"] = logger
            return self
        
        def data(self, data: Dict[str, Any]) -> "NotificationConsumerService._Builder":
            """Set all data at once."""
            self._data.update(data)
            return self
        
        def build(self) -> "NotificationConsumerService":
            """
            Build and return the NotificationConsumerService instance.
            
            Returns:
                Constructed NotificationConsumerService
            """
            return self.cls(**self._data)
