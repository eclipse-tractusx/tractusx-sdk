#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2026 LKS NEXT
# Copyright (c) 2026 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by Co-Pilot and reviewed by a human developer.

"""
Notification Service for connector asset management.

Provides high-level operations for managing DigitalTwinEventAPI assets
in the EDC connector with optional authentication support.
"""

import logging
from typing import Any, Dict, Optional

from tractusx_sdk.dataspace.services.connector.base_connector_provider import BaseConnectorProviderService

from ..constants import DIGITAL_TWIN_EVENT_API_TYPE
from ..exceptions import NotificationError


class NotificationService:
    """
    Service for managing DigitalTwinEventAPI assets in the EDC connector.
    
    This service provides operations for creating and finding notification
    assets (cx-taxo:DigitalTwinEventAPI) in the Catena-X dataspace connector.
    
    Attributes:
        _connector_provider: Connector provider for asset management
        verbose: Enable verbose logging
        logger: Logger instance for this service
    """
    
    # Asset type constant for DigitalTwinEventAPI
    DIGITAL_TWIN_EVENT_API_TYPE = DIGITAL_TWIN_EVENT_API_TYPE
    
    _connector_provider: Optional[BaseConnectorProviderService]
    verbose: bool
    logger: logging.Logger
    
    def __init__(
        self,
        connector_provider: Optional[BaseConnectorProviderService] = None,
        verbose: bool = True,
        logger: Optional[logging.Logger] = None,
    ):
        """
        Initialize the NotificationService.
        
        Args:
            connector_provider: Connector provider service for asset management
            verbose: Enable verbose logging (default: True)
            logger: Optional custom logger instance
        """
        self.verbose = verbose
        self.logger = logger or logging.getLogger(__name__)
        self._connector_provider = connector_provider
    
    @property
    def connector_provider(self) -> Optional[BaseConnectorProviderService]:
        """Get the underlying connector provider service."""
        return self._connector_provider
    
    def ensure_notification_asset_exists(
        self,
        asset_id: str,
        notification_endpoint_url: str,
        version: str = "3.0",
        semantic_id: Optional[str] = None,
        proxy_params: Optional[Dict[str, str]] = None,
        headers: Optional[Dict[str, str]] = None,
        private_properties: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Ensure a DigitalTwinEventAPI asset exists in the connector.
        
        Checks if an asset with the specified ID and dct:type of cx-taxo:DigitalTwinEventAPI
        exists. If not, creates it.
        
        Args:
            asset_id: Unique identifier for the notification asset
            notification_endpoint_url: Base URL for the notification endpoint
            version: Asset version (default: "3.0")
            semantic_id: Optional semantic ID for the asset
            proxy_params: Optional proxy configuration for the data address
            headers: Optional headers for the data address
            private_properties: Optional private properties for the asset
            
        Returns:
            Dictionary containing asset information (existing or newly created)
            
        Raises:
            NotificationError: If connector provider is not configured or operation fails
        """
        if self._connector_provider is None:
            raise NotificationError(
                "Connector provider is required for asset management. "
                "Initialize the service with a connector_provider parameter."
            )
        
        # Check if asset already exists
        existing_asset = self._find_notification_asset(asset_id)
        
        if existing_asset is not None:
            if self.verbose:
                self.logger.info(
                    f"DigitalTwinEventAPI asset '{asset_id}' already exists"
                )
            return existing_asset
        
        # Asset doesn't exist, create it
        if self.verbose:
            self.logger.info(
                f"Creating DigitalTwinEventAPI asset '{asset_id}' at {notification_endpoint_url}"
            )
        
        default_proxy_params = {
            "proxyQueryParams": "false",
            "proxyPath": "true",
            "proxyMethod": "true",
            "proxyBody": "true",
        }
        
        return self._connector_provider.create_asset(
            asset_id=asset_id,
            base_url=notification_endpoint_url,
            dct_type=self.DIGITAL_TWIN_EVENT_API_TYPE,
            version=version,
            semantic_id=semantic_id,
            proxy_params=proxy_params or default_proxy_params,
            headers=headers,
            private_properties=private_properties,
        )
    
    def _find_notification_asset(self, asset_id: str) -> Optional[Dict[str, Any]]:
        """
        Find a notification asset by ID.
        
        Args:
            asset_id: The asset ID to search for
            
        Returns:
            Asset data if found, None otherwise
        """
        try:
            # Query the asset by ID
            response = self._connector_provider.assets.get_by_id(asset_id)
            
            if response.status_code == 200:
                asset_data = response.json()
                # Verify it's a DigitalTwinEventAPI type
                properties = asset_data.get("properties", {})
                dct_type = properties.get("dct:type", {})
                
                if isinstance(dct_type, dict):
                    type_id = dct_type.get("@id", "")
                else:
                    type_id = str(dct_type)
                
                if self.DIGITAL_TWIN_EVENT_API_TYPE in type_id:
                    return asset_data
                else:
                    if self.verbose:
                        self.logger.warning(
                            f"Asset '{asset_id}' exists but is not a DigitalTwinEventAPI type "
                            f"(found: {type_id})"
                        )
                    return None
            
            return None
            
        except Exception as e:
            if self.verbose:
                self.logger.debug(f"Asset '{asset_id}' not found: {e}")
            return None
    
    @classmethod
    def builder(cls) -> "NotificationService._Builder":
        """
        Create a builder for fluent service construction.
        
        Returns:
            Builder instance for creating NotificationService
        """
        return cls._Builder(cls)
    
    class _Builder:
        """Builder class for fluent NotificationService construction."""
        
        def __init__(self, cls):
            self.cls = cls
            self._data: Dict[str, Any] = {}
        
        def connector_provider(
            self, connector_provider: BaseConnectorProviderService
        ) -> "NotificationService._Builder":
            """Set the connector provider service for asset management."""
            self._data["connector_provider"] = connector_provider
            return self
        
        def verbose(self, verbose: bool) -> "NotificationService._Builder":
            """Enable or disable verbose logging."""
            self._data["verbose"] = verbose
            return self
        
        def logger(self, logger: logging.Logger) -> "NotificationService._Builder":
            """Set a custom logger."""
            self._data["logger"] = logger
            return self
        
        def build(self) -> "NotificationService":
            """
            Build and return the NotificationService instance.
            
            Returns:
                Constructed NotificationService
            """
            return self.cls(**self._data)
