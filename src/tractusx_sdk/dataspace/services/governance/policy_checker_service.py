#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2025 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by GitHub CoPilot (Claude Sonnet 4) and reviewed by a human committer

from typing import Dict, List, Any, Optional, Set, Tuple
import hashlib
from sqlmodel import Session, select
from ...models.governance.policy_db_models import (
    Policy, PolicyUsage, FilterExpression, Permission, Prohibition, Duty,
    Rule, Action, Constraint, AtomicConstraint, LeftOperand, RightOperand,
    ActionType, OperatorType, LogicType, PolicyUsageRole, ConstraintAtomicLink
)


class AssetValidationResult:
    """Result of asset validation from catalog"""
    
    def __init__(self, asset_id: str, is_valid: bool, reason: str = "", 
                 matched_policy_hash: str = "", policy_json: Dict[str, Any] = None):
        self.asset_id = asset_id
        self.is_valid = is_valid
        self.reason = reason
        self.matched_policy_hash = matched_policy_hash
        self.policy_json = policy_json or {}


class CatalogValidationResult:
    """Result of catalog validation"""
    
    def __init__(self, asset_results: List[AssetValidationResult]):
        self.asset_results = asset_results
        self.valid_assets = [result for result in asset_results if result.is_valid]
        self.invalid_assets = [result for result in asset_results if not result.is_valid]
    
    def get_safe_assets(self) -> List[Tuple[str, str]]:
        """Get list of (asset_id, policy_hash) tuples for safe assets"""
        return [(result.asset_id, result.matched_policy_hash) for result in self.valid_assets]


class PolicyValidationResult:
    """Result of policy validation"""
    
    def __init__(self, is_valid: bool, reason: str = "", matched_policies: List[str] = None):
        self.is_valid = is_valid
        self.reason = reason
        self.matched_policies = matched_policies or []


class PolicyCheckerService:
    """
    Validates policies against stored policy rules using hash-based matching for performance.
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self._policy_hash_cache: Set[str] = set()
        self._filter_hash_cache: Set[str] = set()
        self._load_policy_hashes()
    
    def _load_policy_hashes(self):
        """Pre-load all policy and filter expression hashes for fast lookup"""
        # Load policy hashes
        policies = self.db_session.exec(select(Policy)).all()
        self._policy_hash_cache = {policy.hash for policy in policies}
        
        # Load filter expression hashes
        filters = self.db_session.exec(select(FilterExpression)).all()
        self._filter_hash_cache = {filter_expr.hash for filter_expr in filters}
    
    def validate_policy(self, policy_json: Dict[str, Any], filter_expressions: List[Dict[str, Any]], 
                       role: PolicyUsageRole = PolicyUsageRole.CONSUMER, 
                       counter_party_id: Optional[str] = None) -> PolicyValidationResult:
        """
        Validates if a given policy JSON is valid based on stored rules and filter expressions.
        
        Args:
            policy_json: The policy in JSON-LD format
            filter_expressions: List of filter expressions to match against
            role: The role (provider/consumer) for policy usage
            counter_party_id: Optional counter party identifier
            
        Returns:
            PolicyValidationResult with validation status and details
        """
        try:
            # Generate hash for the incoming policy
            policy_hash = self._generate_policy_hash(policy_json)
            
            # Check if policy exists in our database
            if policy_hash not in self._policy_hash_cache:
                return PolicyValidationResult(
                    is_valid=False, 
                    reason=f"Policy with hash {policy_hash} not found in approved policies"
                )
            
            # Generate hashes for filter expressions
            filter_hashes = [self._generate_filter_hash(expr) for expr in filter_expressions]
            
            # Check if all filter expressions are valid
            invalid_filters = [hash_val for hash_val in filter_hashes if hash_val not in self._filter_hash_cache]
            if invalid_filters:
                return PolicyValidationResult(
                    is_valid=False,
                    reason=f"Invalid filter expressions found: {invalid_filters}"
                )
            
            # Find matching policy usages
            matching_usages = self._find_matching_policy_usages(
                policy_hash, filter_hashes, role, counter_party_id
            )
            
            if not matching_usages:
                return PolicyValidationResult(
                    is_valid=False,
                    reason="No matching policy usage found for the given criteria"
                )
            
            return PolicyValidationResult(
                is_valid=True,
                reason="Policy validation successful",
                matched_policies=[usage.policy.hash for usage in matching_usages]
            )
            
        except Exception as e:
            return PolicyValidationResult(
                is_valid=False,
                reason=f"Validation error: {str(e)}"
            )
    
    def _generate_policy_hash(self, policy_json: Dict[str, Any]) -> str:
        """Generate hash for a policy JSON structure"""
        permission_hash = ""
        prohibition_hash = ""
        obligation_hash = ""
        
        # Process permission
        if "odrl:permission" in policy_json and policy_json["odrl:permission"]:
            permission_hash = self._generate_permission_hash(policy_json["odrl:permission"])
        
        # Process prohibition
        if "odrl:prohibition" in policy_json and policy_json["odrl:prohibition"]:
            prohibition_hash = self._generate_prohibition_hash(policy_json["odrl:prohibition"])
        
        # Process obligation
        if "odrl:obligation" in policy_json and policy_json["odrl:obligation"]:
            obligation_hash = self._generate_obligation_hash(policy_json["odrl:obligation"])
        
        # Combine hashes using the same method as Policy.generate_hash
        return Policy.generate_hash(permission_hash, prohibition_hash, obligation_hash)
    
    def _generate_permission_hash(self, permission_data: Dict[str, Any]) -> str:
        """Generate hash for permission structure"""
        # Extract action
        action_hash = ""
        if "odrl:action" in permission_data:
            action_type = permission_data["odrl:action"].get("@id", "")
            action_hash = Action.generate_hash(action_type)
        
        # Extract constraint
        constraint_hash = ""
        if "odrl:constraint" in permission_data:
            constraint_hash = self._generate_constraint_hash(permission_data["odrl:constraint"])
        
        # Generate rule hash
        rule_hash = Rule.generate_hash(action_hash, constraint_hash)
        
        # For permission, duty_hash is empty in this example
        duty_hash = ""
        
        return Permission.generate_hash(rule_hash, duty_hash)
    
    def _generate_prohibition_hash(self, prohibition_data: List[Dict[str, Any]]) -> str:
        """Generate hash for prohibition structure"""
        # Implementation similar to permission but for prohibitions
        # For now, return empty hash as the example shows empty prohibition
        return ""
    
    def _generate_obligation_hash(self, obligation_data: List[Dict[str, Any]]) -> str:
        """Generate hash for obligation structure"""
        # Implementation similar to permission but for obligations
        # For now, return empty hash as the example shows empty obligation
        return ""
    
    def _generate_constraint_hash(self, constraint_data: Dict[str, Any]) -> str:
        """Generate hash for constraint structure"""
        if "odrl:and" in constraint_data:
            # Handle AND logic
            atomic_hashes = []
            for atomic_constraint in constraint_data["odrl:and"]:
                atomic_hash = self._generate_atomic_constraint_hash(atomic_constraint)
                atomic_hashes.append(atomic_hash)
            return Constraint.generate_hash(atomic_hashes)
        elif "odrl:or" in constraint_data:
            # Handle OR logic
            atomic_hashes = []
            for atomic_constraint in constraint_data["odrl:or"]:
                atomic_hash = self._generate_atomic_constraint_hash(atomic_constraint)
                atomic_hashes.append(atomic_hash)
            return Constraint.generate_hash(atomic_hashes)
        else:
            # Handle single atomic constraint
            atomic_hash = self._generate_atomic_constraint_hash(constraint_data)
            return Constraint.generate_hash([atomic_hash])
    
    def _generate_atomic_constraint_hash(self, atomic_data: Dict[str, Any]) -> str:
        """Generate hash for atomic constraint"""
        left_operand = atomic_data.get("odrl:leftOperand", {}).get("@id", "")
        operator = atomic_data.get("odrl:operator", {}).get("@id", "")
        right_operand = atomic_data.get("odrl:rightOperand", "")
        
        # Generate hashes for operands
        left_hash = LeftOperand.generate_hash(left_operand)
        right_hash = RightOperand.generate_hash(right_operand)
        
        # For simplicity, using operator string directly for operator_id
        # In real implementation, you'd map to operator ID
        return AtomicConstraint.generate_hash(left_hash, operator, right_hash)
    
    def _generate_filter_hash(self, filter_expr: Dict[str, Any]) -> str:
        """Generate hash for filter expression"""
        left = filter_expr.get("operandLeft", "")
        operator = filter_expr.get("operator", "")
        right = filter_expr.get("operandRight", "")
        
        return FilterExpression.generate_hash(left, operator, right)
    
    def _find_matching_policy_usages(self, policy_hash: str, filter_hashes: List[str], 
                                   role: PolicyUsageRole, counter_party_id: Optional[str]) -> List[PolicyUsage]:
        """Find policy usages that match the criteria"""
        # Get policy by hash
        policy = self.db_session.exec(
            select(Policy).where(Policy.hash == policy_hash)
        ).first()
        
        if not policy:
            return []
        
        # Find policy usages for this policy
        query = select(PolicyUsage).where(
            PolicyUsage.policy_id == policy.id,
            PolicyUsage.role == role
        )
        
        if counter_party_id:
            query = query.where(PolicyUsage.counter_party_id == counter_party_id)
        
        policy_usages = self.db_session.exec(query).all()
        
        # Filter by matching filter expressions
        matching_usages = []
        for usage in policy_usages:
            usage_filter_hashes = {expr.hash for expr in usage.filter_expressions}
            if all(filter_hash in usage_filter_hashes for filter_hash in filter_hashes):
                matching_usages.append(usage)
        
        return matching_usages
    
    def upload_policies_to_database(self, policies: List[Dict[str, Any]], 
                                   role: PolicyUsageRole = PolicyUsageRole.CONSUMER,
                                   counter_party_id: Optional[str] = None) -> List[str]:
        """
        Upload a list of policies to the database with full structure creation.
        
        Args:
            policies: List of policy JSON structures
            role: The role for policy usage
            counter_party_id: Optional counter party identifier
            
        Returns:
            List of policy hashes that were created
        """
        created_hashes = []
        
        for policy_json in policies:
            try:
                policy_hash = self._create_full_policy_in_db(policy_json, role, counter_party_id)
                created_hashes.append(policy_hash)
                self._policy_hash_cache.add(policy_hash)
            except Exception as e:
                print(f"Error uploading policy: {str(e)}")
                continue
        
        return created_hashes
    
    def validate_catalog(self, catalog_json: Dict[str, Any], 
                        role: PolicyUsageRole = PolicyUsageRole.CONSUMER,
                        counter_party_id: Optional[str] = None) -> CatalogValidationResult:
        """
        Validate all assets in a catalog response against stored policies.
        
        Args:
            catalog_json: The catalog response JSON
            role: The role for policy validation
            counter_party_id: Optional counter party identifier
            
        Returns:
            CatalogValidationResult with validation results for all assets
        """
        asset_results = []
        
        # Handle both single dataset and array of datasets
        datasets = catalog_json.get("dcat:dataset", [])
        if isinstance(datasets, dict):
            datasets = [datasets]
        elif not isinstance(datasets, list):
            datasets = []
        
        for dataset in datasets:
            asset_id = dataset.get("@id", dataset.get("id", "unknown"))
            
            # Extract policy from dataset
            policy_json = self._extract_policy_from_dataset(dataset)
            if not policy_json:
                asset_results.append(AssetValidationResult(
                    asset_id=asset_id,
                    is_valid=False,
                    reason="No policy found in dataset"
                ))
                continue
            
            # Normalize and validate policy
            normalized_policy = self._normalize_policy_for_comparison(policy_json)
            policy_hash = self._generate_policy_hash(normalized_policy)
            
            # Check if policy exists in approved policies
            if policy_hash in self._policy_hash_cache:
                asset_results.append(AssetValidationResult(
                    asset_id=asset_id,
                    is_valid=True,
                    reason="Policy matches approved policy",
                    matched_policy_hash=policy_hash,
                    policy_json=normalized_policy
                ))
            else:
                asset_results.append(AssetValidationResult(
                    asset_id=asset_id,
                    is_valid=False,
                    reason=f"Policy with hash {policy_hash} not found in approved policies",
                    matched_policy_hash=policy_hash,
                    policy_json=normalized_policy
                ))
        
        return CatalogValidationResult(asset_results)
    
    def _extract_policy_from_dataset(self, dataset: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Extract policy from dataset structure"""
        # Look for policy in hasPolicy
        has_policy = dataset.get("odrl:hasPolicy")
        if has_policy and isinstance(has_policy, dict):
            return has_policy
        
        # Alternative locations
        policy_locations = [
            "odrl:hasPolicy",
            "policy",
            "dcat:hasPolicy"
        ]
        
        for location in policy_locations:
            policy = dataset.get(location)
            if policy and isinstance(policy, dict):
                return policy
        
        return None
    
    def _normalize_policy_for_comparison(self, policy_json: Dict[str, Any]) -> Dict[str, Any]:
        """
        Normalize policy JSON to ensure consistent hash generation.
        Removes metadata fields that don't affect policy content.
        """
        normalized = {}
        
        # Copy core policy elements, excluding metadata
        core_fields = ["odrl:permission", "odrl:prohibition", "odrl:obligation"]
        for field in core_fields:
            if field in policy_json:
                normalized[field] = policy_json[field]
        
        # Ensure empty arrays for missing fields
        if "odrl:prohibition" not in normalized:
            normalized["odrl:prohibition"] = []
        if "odrl:obligation" not in normalized:
            normalized["odrl:obligation"] = []
        
        return normalized
    
    def _create_full_policy_in_db(self, policy_json: Dict[str, Any], 
                                 role: PolicyUsageRole, 
                                 counter_party_id: Optional[str]) -> str:
        """
        Create a complete policy structure in the database including all related entities.
        """
        # Normalize policy first
        normalized_policy = self._normalize_policy_for_comparison(policy_json)
        
        # First, create the policy with a temporary hash
        policy = Policy(hash="temp_hash")
        self.db_session.add(policy)
        self.db_session.commit()
        self.db_session.refresh(policy)
        
        # Now create policy components with policy_id reference
        permission_hash = ""
        prohibition_hash = ""
        obligation_hash = ""
        
        # Create permission if exists
        if "odrl:permission" in normalized_policy and normalized_policy["odrl:permission"]:
            permission = self._create_permission_in_db(normalized_policy["odrl:permission"], policy.id)
            permission_hash = permission.hash
        
        # Create prohibition if exists (implement as needed)
        if "odrl:prohibition" in normalized_policy and normalized_policy["odrl:prohibition"]:
            # Implementation for prohibition creation
            pass
        
        # Create obligation if exists (implement as needed)
        if "odrl:obligation" in normalized_policy and normalized_policy["odrl:obligation"]:
            # Implementation for obligation creation
            pass
        
        # Update policy with correct hash
        policy_hash = Policy.generate_hash(permission_hash, prohibition_hash, obligation_hash)
        policy.hash = policy_hash
        
        self.db_session.add(policy)
        self.db_session.commit()
        self.db_session.refresh(policy)
        
        # Create policy usage
        policy_usage = PolicyUsage(
            policy_id=policy.id,
            role=role,
            counter_party_id=counter_party_id,
            filter_expressions=[]  # Can be added later if needed
        )
        
        self.db_session.add(policy_usage)
        self.db_session.commit()
        
        return policy_hash
    
    def _create_permission_in_db(self, permission_data: Dict[str, Any], policy_id: int) -> Permission:
        """Create permission and related entities in database"""
        # Create action (check if exists first)
        action_type_str = permission_data.get("odrl:action", {}).get("@id", "")
        action_type = ActionType.USE if "use" in action_type_str else ActionType.ACCESS
        action_hash = Action.generate_hash(action_type.value)
        
        # Check if action already exists
        existing_action = self.db_session.exec(select(Action).where(Action.hash == action_hash)).first()
        if existing_action:
            action = existing_action
        else:
            action = Action(hash=action_hash, type=action_type)
            self.db_session.add(action)
            self.db_session.commit()
            self.db_session.refresh(action)
        
        # Create constraint if exists
        constraint_id = None
        constraint_hash = ""
        if "odrl:constraint" in permission_data:
            constraint_id, constraint_hash = self._create_constraint_in_db(permission_data["odrl:constraint"])
        
        # Create rule (check if exists first)
        rule_hash = Rule.generate_hash(action.hash, constraint_hash)
        existing_rule = self.db_session.exec(select(Rule).where(Rule.hash == rule_hash)).first()
        if existing_rule:
            rule = existing_rule
        else:
            rule = Rule(
                hash=rule_hash,
                action_id=action.id,
                constraint_id=constraint_id
            )
            self.db_session.add(rule)
            self.db_session.commit()
            self.db_session.refresh(rule)
        
        # Create permission with policy_id
        duty_hash = ""  # No duty in this example
        permission_hash = Permission.generate_hash(rule.hash, duty_hash)
        permission = Permission(
            hash=permission_hash,
            rule_id=rule.id,
            duty_id=None,
            policy_id=policy_id
        )
        
        self.db_session.add(permission)
        self.db_session.commit()
        self.db_session.refresh(permission)
        
        return permission
    
    def _create_constraint_in_db(self, constraint_data: Dict[str, Any]) -> Tuple[int, str]:
        """Create constraint and related entities in database"""
        atomic_constraint_ids = []
        atomic_hashes = []
        
        # Handle AND/OR logic
        constraints_list = []
        logic_type = LogicType.AND  # Default
        
        if "odrl:and" in constraint_data:
            constraints_list = constraint_data["odrl:and"]
            logic_type = LogicType.AND
        elif "odrl:or" in constraint_data:
            constraints_list = constraint_data["odrl:or"]
            logic_type = LogicType.OR
        else:
            # Single constraint
            constraints_list = [constraint_data]
        
        # Create atomic constraints
        for atomic_data in constraints_list:
            atomic_id, atomic_hash = self._create_atomic_constraint_in_db(atomic_data)
            atomic_constraint_ids.append(atomic_id)
            atomic_hashes.append(atomic_hash)
        
        # Create constraint (check if exists first)
        constraint_hash = Constraint.generate_hash(atomic_hashes)
        existing_constraint = self.db_session.exec(select(Constraint).where(Constraint.hash == constraint_hash)).first()
        if existing_constraint:
            return existing_constraint.id, existing_constraint.hash
        
        constraint = Constraint(
            hash=constraint_hash,
            logic_type=logic_type
        )
        
        self.db_session.add(constraint)
        self.db_session.commit()
        self.db_session.refresh(constraint)
        
        # Create constraint-atomic links
        for atomic_id in atomic_constraint_ids:
            link = ConstraintAtomicLink(
                constraint_id=constraint.id,
                atomicconstraint_id=atomic_id
            )
            self.db_session.add(link)
        
        self.db_session.commit()
        
        return constraint.id, constraint_hash
    
    def _create_atomic_constraint_in_db(self, atomic_data: Dict[str, Any]) -> Tuple[int, str]:
        """Create atomic constraint and operands in database"""
        # Create left operand (check if exists first)
        left_operand_value = atomic_data.get("odrl:leftOperand", {}).get("@id", "")
        left_hash = LeftOperand.generate_hash(left_operand_value)
        existing_left = self.db_session.exec(select(LeftOperand).where(LeftOperand.hash == left_hash)).first()
        if existing_left:
            left_operand = existing_left
        else:
            left_operand = LeftOperand(hash=left_hash, value=left_operand_value)
            self.db_session.add(left_operand)
            self.db_session.commit()
            self.db_session.refresh(left_operand)
        
        # Create right operand (check if exists first)
        right_operand_value = atomic_data.get("odrl:rightOperand", "")
        right_hash = RightOperand.generate_hash(right_operand_value)
        existing_right = self.db_session.exec(select(RightOperand).where(RightOperand.hash == right_hash)).first()
        if existing_right:
            right_operand = existing_right
        else:
            right_operand = RightOperand(hash=right_hash, value=right_operand_value)
            self.db_session.add(right_operand)
            self.db_session.commit()
            self.db_session.refresh(right_operand)
        
        # Get operator
        operator_str = atomic_data.get("odrl:operator", {}).get("@id", "")
        operator_type = OperatorType.eq if "eq" in operator_str else OperatorType.eq
        
        # Create atomic constraint (check if exists first)
        atomic_hash = AtomicConstraint.generate_hash(left_hash, operator_type.value, right_hash)
        existing_atomic = self.db_session.exec(select(AtomicConstraint).where(AtomicConstraint.hash == atomic_hash)).first()
        if existing_atomic:
            return existing_atomic.id, existing_atomic.hash
        
        atomic_constraint = AtomicConstraint(
            hash=atomic_hash,
            left_operand_id=left_operand.id,
            operator=operator_type,
            right_operand_id=right_operand.id
        )
        
        self.db_session.add(atomic_constraint)
        self.db_session.commit()
        self.db_session.refresh(atomic_constraint)
        
        return atomic_constraint.id, atomic_hash

    def add_approved_policy(self, policy_json: Dict[str, Any], 
                          filter_expressions: List[Dict[str, Any]],
                          role: PolicyUsageRole = PolicyUsageRole.CONSUMER,
                          counter_party_id: Optional[str] = None) -> str:
        """
        Add a new approved policy to the database.
        
        Returns:
            The hash of the created policy
        """
        # Create policy components and save to database
        # This is a simplified version - you'd need to implement full policy creation
        policy_hash = self._generate_policy_hash(policy_json)
        
        # Add to cache
        self._policy_hash_cache.add(policy_hash)
        
        # Add filter expression hashes to cache
        for expr in filter_expressions:
            filter_hash = self._generate_filter_hash(expr)
            self._filter_hash_cache.add(filter_hash)
        
        return policy_hash
    
    def refresh_cache(self):
        """Refresh the hash caches from database"""
        self._policy_hash_cache.clear()
        self._filter_hash_cache.clear()
        self._load_policy_hashes()


# Example usage
def example_usage():
    """Example of how to use the PolicyCheckerService with catalog validation"""
    
    # Sample approved policies to upload to database
    approved_policies = [
        {
            "odrl:permission": {
                "odrl:action": {
                    "@id": "odrl:use"
                },
                "odrl:constraint": {
                    "odrl:and": [
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:FrameworkAgreement"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "DataExchangeGovernance:1.0"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:Membership"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "active"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:UsagePurpose"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "cx.core.digitalTwinRegistry:1"
                        }
                    ]
                }
            },
            "odrl:prohibition": [],
            "odrl:obligation": []
        },
        {
            "odrl:permission": {
                "odrl:action": {
                    "@id": "odrl:use"
                },
                "odrl:constraint": {
                    "odrl:and": [
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:FrameworkAgreement"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "DataExchangeGovernance:1.0"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:Membership"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "active"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:UsagePurpose"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "cx.core.industrycore:1"
                        }
                    ]
                }
            },
            "odrl:prohibition": [],
            "odrl:obligation": []
        }
    ]
    
    # Sample catalog response
    catalog_response = {
        "@id": "4f1bcfb2-7959-4ab7-a091-781a8c76b153",
        "@type": "dcat:Catalog",
        "dcat:dataset": {
            "@id": "ichub:asset:dtr:9foUM7pmSTrr5LZnx0NqiQ",
            "@type": "dcat:Dataset",
            "odrl:hasPolicy": {
                "@id": "policy-id",
                "@type": "odrl:Offer",
                "odrl:permission": {
                    "odrl:action": {
                        "@id": "odrl:use"
                    },
                    "odrl:constraint": {
                        "odrl:and": [
                            {
                                "odrl:leftOperand": {
                                    "@id": "cx-policy:FrameworkAgreement"
                                },
                                "odrl:operator": {
                                    "@id": "odrl:eq"
                                },
                                "odrl:rightOperand": "DataExchangeGovernance:1.0"
                            },
                            {
                                "odrl:leftOperand": {
                                    "@id": "cx-policy:Membership"
                                },
                                "odrl:operator": {
                                    "@id": "odrl:eq"
                                },
                                "odrl:rightOperand": "active"
                            },
                            {
                                "odrl:leftOperand": {
                                    "@id": "cx-policy:UsagePurpose"
                                },
                                "odrl:operator": {
                                    "@id": "odrl:eq"
                                },
                                "odrl:rightOperand": "cx.core.digitalTwinRegistry:1"
                            }
                        ]
                    }
                },
                "odrl:prohibition": [],
                "odrl:obligation": []
            }
        }
    }
    
    # Example usage (you would need a real DB session)
    # from sqlmodel import create_engine, Session, SQLModel
    # engine = create_engine("sqlite:///policies.db")
    # SQLModel.metadata.create_all(engine)
    # 
    # with Session(engine) as session:
    #     checker = PolicyCheckerService(session)
    #     
    #     # Upload approved policies to database
    #     uploaded_hashes = checker.upload_policies_to_database(
    #         approved_policies, 
    #         role=PolicyUsageRole.CONSUMER,
    #         counter_party_id="BPNL0000000093Q7"
    #     )
    #     print(f"Uploaded {len(uploaded_hashes)} policies")
    #     
    #     # Validate catalog
    #     validation_result = checker.validate_catalog(
    #         catalog_response,
    #         role=PolicyUsageRole.CONSUMER,
    #         counter_party_id="BPNL0000000093Q7"
    #     )
    #     
    #     # Get safe assets
    #     safe_assets = validation_result.get_safe_assets()
    #     print(f"Safe assets: {safe_assets}")
    #     
    #     # Check individual asset results
    #     for result in validation_result.asset_results:
    #         print(f"Asset {result.asset_id}: {'VALID' if result.is_valid else 'INVALID'} - {result.reason}")


def example_catalog_validation_usage():
    """
    Specific example showing catalog validation with the provided data
    """
    # The exact policies from your request
    approved_policies = [
        {
            "odrl:permission": {
                "odrl:action": {
                    "@id": "odrl:use"
                },
                "odrl:constraint": {
                    "odrl:and": [
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:FrameworkAgreement"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "DataExchangeGovernance:1.0"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:Membership"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "active"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:UsagePurpose"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "cx.core.digitalTwinRegistry:1"
                        }
                    ]
                }
            },
            "odrl:prohibition": [],
            "odrl:obligation": []
        },
        {
            "odrl:permission": {
                "odrl:action": {
                    "@id": "odrl:use"
                },
                "odrl:constraint": {
                    "odrl:and": [
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:FrameworkAgreement"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "DataExchangeGovernance:1.0"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:Membership"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "active"
                        },
                        {
                            "odrl:leftOperand": {
                                "@id": "cx-policy:UsagePurpose"
                            },
                            "odrl:operator": {
                                "@id": "odrl:eq"
                            },
                            "odrl:rightOperand": "cx.core.industrycore:1"
                        }
                    ]
                }
            },
            "odrl:prohibition": [],
            "odrl:obligation": []
        }
    ]
    
    # This would validate that the asset "ichub:asset:dtr:9foUM7pmSTrr5LZnx0NqiQ" 
    # from your catalog response has a policy that matches the first approved policy
    # (digitalTwinRegistry usage) and therefore is safe to use.
    print("Use the PolicyCheckerService.upload_policies_to_database() and")
    print("PolicyCheckerService.validate_catalog() methods as shown above")
