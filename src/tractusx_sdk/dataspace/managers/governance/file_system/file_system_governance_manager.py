#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2025 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by GitHub CoPilot (Claude Sonnet 4) and reviewed by a human committer.

import os
import json
from pathlib import Path
from typing import Dict, List, Any, Tuple

from ..memory.memory_governance_manager import MemoryGovernanceManager


class FileSystemGovernanceManager(MemoryGovernanceManager):
    """
    Filesystem implementation of governance manager.
    Stores policies as JSON files in a directory structure organized by hash.
    """

    def __init__(self, policies_directory: str = "./policies", **kwargs):
        """
        Initialize the filesystem governance manager.
        
        Args:
            policies_directory: Directory to store policy files
            **kwargs: Additional configuration
        """
        self.policies_directory = Path(policies_directory)
        self.policies_directory.mkdir(parents=True, exist_ok=True)
        
        # Create subdirectories for organization
        self.policies_dir = self.policies_directory / "policies"
        self.policies_dir.mkdir(exist_ok=True)

    def _get_policy_file_path(self, policy_hash: str) -> Path:
        """Get the file path for a policy given its hash."""
        return self.policies_dir / f"{policy_hash}.json"

    def _load_policy_from_file(self, policy_hash: str) -> Dict[str, Any] | None:
        """Load a policy from file by its hash."""
        file_path = self._get_policy_file_path(policy_hash)
        try:
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception:
            pass
        return None

    def _save_policy_to_file(self, policy_hash: str, policy_json: Dict[str, Any]) -> bool:
        """Save a policy to file."""
        file_path = self._get_policy_file_path(policy_hash)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(policy_json, f, indent=2, sort_keys=True)
            return True
        except Exception:
            return False

    def add_policy(self, json_policy: Dict[str, Any]) -> str:
        """
        Add a policy to the filesystem.
        
        Args:
            json_policy: The policy in JSON format
            
        Returns:
            str: The hash of the normalized policy
        """
        normalized_policy = self.normalize_policy(json_policy)
        policy_hash = self.generate_policy_hash(normalized_policy)
        
        # Save to file
        if self._save_policy_to_file(policy_hash, normalized_policy):
            return policy_hash
        else:
            raise RuntimeError(f"Failed to save policy {policy_hash} to filesystem")

    def remove_policy(self, policy_hash: str) -> bool:
        """
        Remove a policy from the filesystem.
        
        Args:
            policy_hash: The hash of the policy to remove
            
        Returns:
            bool: True if policy was removed, False if not found
        """
        file_path = self._get_policy_file_path(policy_hash)
        try:
            if file_path.exists():
                file_path.unlink()
                return True
        except Exception:
            pass
        return False

    def is_policy_valid(self, json_policy: Dict[str, Any]) -> bool:
        """
        Check if a policy is valid (exists in the filesystem).
        
        Args:
            json_policy: The policy in JSON format to validate
            
        Returns:
            bool: True if policy is valid, False otherwise
        """
        normalized_policy = self.normalize_policy(json_policy)
        policy_hash = self.generate_policy_hash(normalized_policy)
        file_path = self._get_policy_file_path(policy_hash)
        return file_path.exists()

    def select_valid_policies(self, policies: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Filter a list of policies and return only the valid ones.
        
        Args:
            policies: List of policies in JSON format
            
        Returns:
            List[Dict[str, Any]]: List of valid policies
        """
        valid_policies = []
        for policy in policies:
            if self.is_policy_valid(policy):
                valid_policies.append(policy)
        return valid_policies

    def select_valid_assets_and_policies(self, dcat_dataset: Dict[str, Any]) -> List[Tuple[str, str]]:
        """
        Extract and validate assets and their policies from a DCAT dataset.
        
        Args:
            dcat_dataset: The DCAT dataset containing assets and policies
            
        Returns:
            List[Tuple[str, str]]: List of tuples (asset_id, policy_hash) for valid combinations
        """
        valid_combinations = []
        
        # Handle both single dataset and array of datasets
        datasets = dcat_dataset.get("dcat:dataset", [])
        if isinstance(datasets, dict):
            datasets = [datasets]
        elif not isinstance(datasets, list):
            datasets = []
        
        for dataset in datasets:
            asset_id = self.extract_asset_id(dataset)
            
            # Extract policy from dataset
            policy_json = self.extract_policy_from_dataset(dataset)
            if not policy_json:
                continue
            
            # Check if policy is valid
            if self.is_policy_valid(policy_json):
                normalized_policy = self.normalize_policy(policy_json)
                policy_hash = self.generate_policy_hash(normalized_policy)
                valid_combinations.append((asset_id, policy_hash))
        
        return valid_combinations

    def get_policy_count(self) -> int:
        """
        Get the total number of policies in the filesystem.
        
        Returns:
            int: Number of policies
        """
        try:
            return len([f for f in self.policies_dir.glob("*.json") if f.is_file()])
        except Exception:
            return 0

    def list_policy_hashes(self) -> List[str]:
        """
        Get a list of all policy hashes in the filesystem.
        
        Returns:
            List[str]: List of policy hashes
        """
        try:
            return [f.stem for f in self.policies_dir.glob("*.json") if f.is_file()]
        except Exception:
            return []

    def get_policy_by_hash(self, policy_hash: str) -> Dict[str, Any] | None:
        """
        Get a policy by its hash.
        
        Args:
            policy_hash: The hash of the policy
            
        Returns:
            Dict[str, Any] | None: The policy if found, None otherwise
        """
        return self._load_policy_from_file(policy_hash)

    def load_policies_from_directory(self, source_directory: str) -> List[str]:
        """
        Load policies from a source directory into the governance store.
        
        Args:
            source_directory: Directory containing policy JSON files
            
        Returns:
            List[str]: List of policy hashes that were loaded
        """
        source_path = Path(source_directory)
        loaded_hashes = []
        
        if not source_path.exists():
            return loaded_hashes
        
        for json_file in source_path.glob("*.json"):
            try:
                with open(json_file, 'r', encoding='utf-8') as f:
                    policy_json = json.load(f)
                    policy_hash = self.add_policy(policy_json)
                    loaded_hashes.append(policy_hash)
            except Exception as e:
                print(f"Warning: Could not load policy from {json_file}: {e}")
        
        return loaded_hashes

    def export_policies_to_directory(self, target_directory: str) -> bool:
        """
        Export all policies to a target directory.
        
        Args:
            target_directory: Directory to export policies to
            
        Returns:
            bool: True if export was successful
        """
        try:
            target_path = Path(target_directory)
            target_path.mkdir(parents=True, exist_ok=True)
            
            for policy_file in self.policies_dir.glob("*.json"):
                target_file = target_path / policy_file.name
                target_file.write_text(policy_file.read_text(encoding='utf-8'), encoding='utf-8')
            
            return True
        except Exception:
            return False

    def clear_policies(self):
        """Clear all policies from the filesystem."""
        try:
            for policy_file in self.policies_dir.glob("*.json"):
                policy_file.unlink()
        except Exception:
            pass
