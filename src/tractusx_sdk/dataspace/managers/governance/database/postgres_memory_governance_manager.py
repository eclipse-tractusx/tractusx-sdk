#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2025 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by GitHub CoPilot (Claude Sonnet 4) and reviewed by a human committer.

from typing import Dict, List, Any, Tuple
from sqlmodel import Session
from ..memory.memory_governance_manager import MemoryGovernanceManager


class PostgresMemoryGovernanceManager(MemoryGovernanceManager):
    """
    Hybrid implementation of governance manager.
    Uses in-memory storage for fast access with database persistence as backup.
    
    The in-memory store acts as a cache with the database as the authoritative source.
    """

    def __init__(self, db_session: Session, **kwargs):
        """
        Initialize the hybrid governance manager.
        
        Args:
            db_session: SQLModel database session
            **kwargs: Additional configuration including:
                - sync_on_startup: bool (default True) - Load all policies from DB to memory on init
                - auto_persist: bool (default True) - Automatically persist memory changes to DB
                - role: PolicyUsageRole (default CONSUMER)
                - counter_party_id: Optional[str]
        """
        super().__init__()
        self.db_session = db_session
        self.sync_on_startup = kwargs.get('sync_on_startup', True)
        self.auto_persist = kwargs.get('auto_persist', True)
        
        if self.sync_on_startup:
            self._sync_from_database()

    def _sync_from_database(self):
        """Load all policies from database into memory."""
        try:
            # Get all policy hashes from database
            policy_hashes = self.database_manager.list_policy_hashes()
            
            # Note: In a real implementation, you'd need a way to get the full policy JSON
            # from the database by hash. For now, we'll just sync the hashes.
            # This is a limitation of the current database design.
            
            # Clear memory and reload (this is a simplified approach)
            self.memory_manager.clear_policies()
            
            # If you had a method to get policy JSON by hash from database:
            # for policy_hash in policy_hashes:
            #     policy_json = self.database_manager.get_policy_json_by_hash(policy_hash)
            #     if policy_json:
            #         self.memory_manager.policies[policy_hash] = policy_json
            
        except Exception as e:
            print(f"Warning: Could not sync from database: {e}")

    def _persist_to_database(self, json_policy: Dict[str, Any]) -> str:
        """Persist a policy to the database."""
        if self.auto_persist:
            return self.database_manager.add_policy(json_policy)
        return self.generate_policy_hash(json_policy)

    def add_policy(self, json_policy: Dict[str, Any]) -> str:
        """
        Add a policy to both memory and database.
        
        Args:
            json_policy: The policy in JSON format
            
        Returns:
            str: The hash of the normalized policy
        """
        # Add to memory first (fast)
        memory_hash = self.memory_manager.add_policy(json_policy)
        
        # Persist to database if auto_persist is enabled
        if self.auto_persist:
            try:
                db_hash = self.database_manager.add_policy(json_policy)
                # Verify hashes match
                if memory_hash != db_hash:
                    print(f"Warning: Hash mismatch between memory ({memory_hash}) and database ({db_hash})")
            except Exception as e:
                print(f"Warning: Failed to persist policy to database: {e}")
        
        return memory_hash

    def remove_policy(self, policy_hash: str) -> bool:
        """
        Remove a policy from both memory and database.
        
        Args:
            policy_hash: The hash of the policy to remove
            
        Returns:
            bool: True if policy was removed from memory, False if not found
        """
        # Remove from memory
        memory_removed = self.memory_manager.remove_policy(policy_hash)
        
        # Remove from database if auto_persist is enabled
        if self.auto_persist:
            try:
                self.database_manager.remove_policy(policy_hash)
            except Exception as e:
                print(f"Warning: Failed to remove policy from database: {e}")
        
        return memory_removed

    def is_policy_valid(self, json_policy: Dict[str, Any]) -> bool:
        """
        Check if a policy is valid using the fast in-memory store.
        
        Args:
            json_policy: The policy in JSON format to validate
            
        Returns:
            bool: True if policy is valid, False otherwise
        """
        return self.memory_manager.is_policy_valid(json_policy)

    def select_valid_policies(self, policies: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Filter a list of policies using the fast in-memory store.
        
        Args:
            policies: List of policies in JSON format
            
        Returns:
            List[Dict[str, Any]]: List of valid policies
        """
        return self.memory_manager.select_valid_policies(policies)

    def select_valid_assets_and_policies(self, dcat_dataset: Dict[str, Any]) -> List[Tuple[str, str]]:
        """
        Extract and validate assets and their policies using in-memory store.
        
        Args:
            dcat_dataset: The DCAT dataset containing assets and policies
            
        Returns:
            List[Tuple[str, str]]: List of tuples (asset_id, policy_hash) for valid combinations
        """
        return self.memory_manager.select_valid_assets_and_policies(dcat_dataset)

    def get_policy_count(self) -> int:
        """
        Get the total number of policies in memory.
        
        Returns:
            int: Number of policies in memory
        """
        return self.memory_manager.get_policy_count()

    def list_policy_hashes(self) -> List[str]:
        """
        Get a list of all policy hashes from memory.
        
        Returns:
            List[str]: List of policy hashes
        """
        return self.memory_manager.list_policy_hashes()

    def sync_to_database(self):
        """Manually sync all memory policies to database."""
        if not self.auto_persist:
            for policy_hash, policy_json in self.memory_manager.policies.items():
                try:
                    self.database_manager.add_policy(policy_json)
                except Exception as e:
                    print(f"Warning: Failed to sync policy {policy_hash} to database: {e}")

    def sync_from_database(self):
        """Manually sync all database policies to memory."""
        self._sync_from_database()

    def get_memory_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the memory store.
        
        Returns:
            Dict[str, Any]: Statistics including policy count and hashes
        """
        return {
            "policy_count": self.memory_manager.get_policy_count(),
            "policy_hashes": self.memory_manager.list_policy_hashes(),
            "auto_persist": self.auto_persist
        }

    def get_database_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the database store.
        
        Returns:
            Dict[str, Any]: Statistics including policy count and hashes
        """
        return {
            "policy_count": self.database_manager.get_policy_count(),
            "policy_hashes": self.database_manager.list_policy_hashes()
        }

    def load_policies_from_list(self, policies: List[Dict[str, Any]]) -> List[str]:
        """
        Load multiple policies into both memory and database.
        
        Args:
            policies: List of policy JSONs
            
        Returns:
            List[str]: List of policy hashes that were added
        """
        added_hashes = []
        for policy in policies:
            policy_hash = self.add_policy(policy)
            added_hashes.append(policy_hash)
        return added_hashes
