#################################################################################
# Eclipse Tractus-X - Software Development KIT
#
# Copyright (c) 2025 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the
# License for the specific language govern in permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
#################################################################################

# Part of this content was generated by GitHub CoPilot (Claude Sonnet 4) and reviewed by a human committer

from sqlmodel import SQLModel, Field, Relationship
from typing import Optional, List
from enum import Enum
import hashlib
from sqlalchemy import JSON

class PolicyUsageRole(str, Enum):
    PROVIDER = "provider"
    CONSUMER = "consumer"

# ENUMS
class ActionType(str, Enum):
    USE = "odrl:use"
    ACCESS = "odrl:access"

class OperatorType(str, Enum):
    eq = "odrl:eq"
    gt = "odrl:gt"
    gteq = "odrl:gteq"
    lteq = "odrl:lteq"
    hasPart = "odrl:hasPart"
    isA = "odrl:isA"
    isAllOf = "odrl:isAllOf"
    isAnyOf = "odrl:isAnyOf"
    isNoneOf = "odrl:isNoneOf"
    isPartOf = "odrl:isPartOf"
    lt = "odrl:lt"
    term_lteq = "odrl:term-lteq"
    neq = "odrl:neq"

class LogicType(str, Enum):
    ATOMIC = "atomic"
    AND = "odrl:and"
    OR = "odrl:or"

# CORE ELEMENTS
class LeftOperand(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    value: str
    hash: str = Field(index=True, unique=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(kwargs.get("value", ""))

    @staticmethod
    def generate_hash(value: str) -> str:
        return hashlib.sha256(value.encode()).hexdigest()


class RightOperand(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    value: str
    hash: str = Field(index=True, unique=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(kwargs.get("value", ""))

    @staticmethod
    def generate_hash(value: str) -> str:
        return hashlib.sha256(value.encode()).hexdigest()

class AtomicConstraint(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    left_operand_id: int = Field(foreign_key="leftoperand.id")
    operator: OperatorType = Field(default=OperatorType.eq)
    right_operand_id: int = Field(foreign_key="rightoperand.id")
    hash: str = Field(index=True, unique=True)

    left_operand: "LeftOperand" = Relationship()
    right_operand: "RightOperand" = Relationship()

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(
                str(kwargs.get("left_operand_id")),
                str(kwargs.get("operator", OperatorType.eq)),
                str(kwargs.get("right_operand_id")),
            )

    @staticmethod
    def generate_hash(left: str, op: str, right: str) -> str:
        raw = f"{left}:{op}:{right}"
        return hashlib.sha256(raw.encode()).hexdigest()

class Constraint(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    logic_type: LogicType
    # relationship: multiple AtomicConstraint entries
    constraints: List["ConstraintAtomicLink"] = Relationship(back_populates="constraint")
    hash: str = Field(index=True, unique=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            # constraints is a list of ConstraintAtomicLink, each has .atomicconstraint with .hash
            atomic_hashes = [link.atomicconstraint.hash for link in kwargs.get("constraints", [])]
            raw = ":".join(sorted(atomic_hashes))
            self.hash = hashlib.sha256(raw.encode()).hexdigest()

    @staticmethod
    def generate_hash(atomic_hashes: list) -> str:
        raw = ":".join(sorted(atomic_hashes))
        return hashlib.sha256(raw.encode()).hexdigest()

    @property
    def atomic_constraints(self) -> List["AtomicConstraint"]:
        return [m.atomicconstraint for m in self.constraints]


class ConstraintAtomicLink(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    constraint_id: int = Field(foreign_key="constraint.id")
    atomicconstraint_id: int = Field(foreign_key="atomicconstraint.id")

    constraint: "Constraint" = Relationship(back_populates="constraints")
    atomicconstraint: "AtomicConstraint" = Relationship()


class Action(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    type: ActionType
    hash: str = Field(index=True, unique=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(kwargs.get("type", ""))

    @staticmethod
    def generate_hash(action_type: str) -> str:
        return hashlib.sha256(action_type.encode()).hexdigest()

# RULE
class Rule(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    action_id: int = Field(foreign_key="action.id")
    constraint_id: int = Field(foreign_key="constraint.id")
    hash: str = Field(index=True, unique=True)

    action: "Action" = Relationship()
    constraint: "Constraint" = Relationship()

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            # If action and constraint objects are already provided, use their hashes.
            action = kwargs.get("action", None)
            constraint = kwargs.get("constraint", None)
            self.hash = self.generate_hash(
                action.hash if action else "",
                constraint.hash if constraint else ""
            )


    @staticmethod
    def generate_hash(action_hash: str, constraint_hash: str) -> str:
        raw = f"{action_hash}:{constraint_hash}"
        return hashlib.sha256(raw.encode()).hexdigest()


# POLICY TYPES
class Permission(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    rule_id: int = Field(foreign_key="rule.id")
    duty_id: Optional[int] = Field(foreign_key="duty.id", default=None)
    policy_id: int = Field(foreign_key="policy.id")
    hash: str = Field(index=True, unique=True)

    rule: "Rule" = Relationship()
    duty: Optional["Duty"] = Relationship()
    policy: Optional["Policy"] = Relationship(back_populates="permissions")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(
                self.rule.hash if self.rule else "",
                self.duty.hash if self.duty else ""
            )

    @staticmethod
    def generate_hash(rule_hash: str, duty_hash: str) -> str:
        raw = f"{rule_hash}:{duty_hash}"
        return hashlib.sha256(raw.encode()).hexdigest()


class Prohibition(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    rule_id: int = Field(foreign_key="rule.id")
    remedy_id: Optional[int] = Field(foreign_key="duty.id", default=None)  # Using Duty table for remedy as you specified
    policy_id: int = Field(foreign_key="policy.id")
    hash: str = Field(index=True, unique=True)

    rule: "Rule" = Relationship()
    remedy: Optional["Duty"] = Relationship()
    policy: Optional["Policy"] = Relationship(back_populates="prohibitions")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(
                self.rule.hash if self.rule else "",
                self.remedy.hash if self.remedy else ""
            )

    @staticmethod
    def generate_hash(rule_hash: str, remedy_hash: str) -> str:
        raw = f"{rule_hash}:{remedy_hash}"
        return hashlib.sha256(raw.encode()).hexdigest()


class Duty(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    rule_id: int = Field(foreign_key="rule.id")
    consequence_id: Optional[int] = Field(foreign_key="duty.id", default=None)  # Using Duty table for consequence
    policy_id: int = Field(foreign_key="policy.id")
    hash: str = Field(index=True, unique=True)

    rule: "Rule" = Relationship()
    consequence: Optional["Duty"] = Relationship()
    policy: Optional["Policy"] = Relationship(back_populates="obligations")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(
                self.rule.hash if self.rule else "",
                self.consequence.hash if self.consequence else ""
            )

    @staticmethod
    def generate_hash(rule_hash: str, consequence_hash: str) -> str:
        raw = f"{rule_hash}:{consequence_hash}"
        return hashlib.sha256(raw.encode()).hexdigest()


# POLICY MODEL
class Policy(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    hash: str = Field(index=True, unique=True)

    permissions: List["Permission"] = Relationship(back_populates="policy")
    prohibitions: List["Prohibition"] = Relationship(back_populates="policy")
    obligations: List["Duty"] = Relationship(back_populates="policy")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            self.hash = self.generate_hash(
                kwargs.get("permission").hash if kwargs.get("permission") else "",
                kwargs.get("prohibition").hash if kwargs.get("prohibition") else "",
                kwargs.get("obligation").hash if kwargs.get("obligation") else ""
            )
    
    @staticmethod
    def generate_hash(permission_hash: str, prohibition_hash: str, obligation_hash: str) -> str:
        combined = ":".join(sorted([permission_hash, prohibition_hash, obligation_hash]))
        return hashlib.sha256(combined.encode()).hexdigest()
    

class PolicyUsage(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    policy_id: int = Field(foreign_key="policy.id")
    role: PolicyUsageRole = Field(default=PolicyUsageRole.CONSUMER)
    counter_party_id: Optional[str] = Field(default=None)

    policy: "Policy" = Relationship()
    filter_expressions: List["FilterExpression"] = Relationship(back_populates="policy_usage")

class FilterExpression(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    policy_usage_id: int = Field(foreign_key="policyusage.id")
    operand_left: str
    operator: str
    operand_right: str
    hash: str = Field(index=True, unique=True)

    policy_usage: "PolicyUsage" = Relationship(back_populates="filter_expressions")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if "hash" not in kwargs:
            left = kwargs.get("operand_left", "")
            op = kwargs.get("operator", "")
            right = kwargs.get("operand_right", "")
            self.hash = self.generate_hash(left, op, right)

    @staticmethod
    def generate_hash(left: str, operator: str, right: str) -> str:
        raw = f"{left}:{operator}:{right}"
        return hashlib.sha256(raw.encode()).hexdigest()